<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>springboot异常处理</title>
      <link href="/2025/07/03/SpringBoot%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2025/07/03/SpringBoot%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot异常处理"><a href="#springboot异常处理" class="headerlink" title="springboot异常处理"></a>springboot异常处理</h1><h2 id="1-1-默认规则"><a href="#1-1-默认规则" class="headerlink" title="1.1 默认规则"></a>1.1 默认规则</h2><p>Spring Boot 提供了内置的错误处理机制，默认情况下，它通过 <code>BasicErrorController</code> 处理错误。主要的默认规则包括：</p><ol><li><p><strong>响应类型</strong></p><p><code>BasicErrorController</code> 中的两个RequestMapping</p><p><img src="/../images/image-20240819202054517.png" alt="image-20240819202054517"></p><p>浏览器发送请求的时候，我们在控制台可以看到它优先接收 <code>text/html</code> 类型的数据，）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/75f5a8edd3138532103da46742bdbb16.png#pic_center" alt="在这里插入图片描述"></p></li></ol><p>而其它客户端（例如Postman）发送请求的时候，它没有说它要优先接收 <code>text/html</code> 类型的数据</p><p>   <img src="https://i-blog.csdnimg.cn/blog_migrate/476a3b0b696763bf09015d89fc7ff0d3.png#pic_center" alt="在这里插入图片描述"></p><ol start="2"><li><p><strong>默认错误响应</strong></p><ul><li>当请求遇到异常或 HTTP 错误状态码时，Spring Boot 会返回一个标准化的 JSON 错误响应。这个响应包括错误状态码、错误类型、错误消息和请求路径。</li><li>示例响应格式：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-08-19T12:00:00.000+00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">404</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Not Found&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;No message available&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/some/path&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>默认错误页面</strong>：</p><ul><li><p>Spring Boot 提供了简单的 HTML 错误页面用于处理常见的 HTTP 错误（如 404、500）。</p></li><li><p>错误页面的文件路径通常是 <code>src/main/resources/templates/error/404.html</code> 和 <code>src/main/resources/templates/error/500.html</code>。</p><p><img src="/../images/image-20240819201352058.png" alt="image-20240819201352058"></p></li></ul><p>2.1 <strong>DefaultErrorViewResolver 解析流程</strong>，</p><p>结论就是：</p><p>有模板引擎的情况下，将错误页面放在 templates&#x2F;error&#x2F; 即可<br>没有模板引擎的情况下，将错误页面放在 静态资源文件夹&#x2F;error&#x2F; 即可<br>我们可以使用4xx，5xx作为页面的文件名来匹配这种类型所有的错误，精确优先（因为代码执行顺序优先）</p></li><li><p><strong>配置默认错误处理</strong>：</p><ul><li>可以通过 <code>application.properties</code> 或 <code>application.yml</code> 配置错误处理行为。例如：<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.error.whitelabel.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">server.error.path</span>=<span class="string">/error</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-2-ControllerAdvice"><a href="#1-2-ControllerAdvice" class="headerlink" title="1.2 @ControllerAdvice"></a>1.2 @ControllerAdvice</h2><p><code>@ControllerAdvice</code> 是 Spring Framework 提供的一个用于全局异常处理的注解。它可以定义一个全局的异常处理类，该类能够捕获和处理应用程序中所有控制器的异常。</p><h3 id="功能和用法："><a href="#功能和用法：" class="headerlink" title="功能和用法："></a>功能和用法：</h3><ol><li><strong>定义全局异常处理</strong>：</li></ol><ul><li>使用 <code>@ControllerAdvice</code> 注解的类可以定义全局异常处理方法，这些方法通过 <code>@ExceptionHandler</code> 注解来指定处理特定异常的逻辑。</li></ul><ol start="2"><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseStatus;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handleGenericException</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(<span class="string">&quot;An unexpected error occurred&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在上面的示例中，<code>handleResourceNotFoundException</code> 方法会处理 <code>ResourceNotFoundException</code> 异常，返回 404 状态码和异常消息。</li><li><code>handleGenericException</code> 方法会处理所有其他未处理的异常，返回 500 状态码和默认错误消息。</li></ul></li></ol><h2 id="1-3-RestControllerAdvice-并举例"><a href="#1-3-RestControllerAdvice-并举例" class="headerlink" title="1.3 @RestControllerAdvice 并举例"></a>1.3 @RestControllerAdvice 并举例</h2><p><code>@RestControllerAdvice</code> 是 <code>@ControllerAdvice</code> 和 <code>@ResponseBody</code> 的组合，通常用于处理 RESTful 风格的应用程序中的异常。它能够处理异常，并直接返回 JSON 或其他媒体类型的响应，而不是 HTML 页面。</p><h3 id="功能和用法：-1"><a href="#功能和用法：-1" class="headerlink" title="功能和用法："></a>功能和用法：</h3><ol><li><strong>定义 RESTful 风格的全局异常处理</strong>：</li></ol><ul><li>使用 <code>@RestControllerAdvice</code> 注解的类可以定义全局异常处理方法，返回 JSON 格式的错误响应。</li></ul><ol start="2"><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestGlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex)</span> &#123;</span><br><span class="line">        <span class="type">ErrorResponse</span> <span class="variable">errorResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(HttpStatus.NOT_FOUND.value(), ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorResponse&gt; <span class="title function_">handleGenericException</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        <span class="type">ErrorResponse</span> <span class="variable">errorResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorResponse</span>(HttpStatus.INTERNAL_SERVER_ERROR.value(), <span class="string">&quot;An unexpected error occurred&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrorResponse class to standardize error responses</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorResponse</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> status;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ErrorResponse</span><span class="params">(<span class="type">int</span> status, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在上面的示例中，<code>handleResourceNotFoundException</code> 方法会处理 <code>ResourceNotFoundException</code> 异常，并返回包含状态码和错误消息的 JSON 响应。</li><li><code>handleGenericException</code> 方法会处理所有其他未处理的异常，并返回通用的 JSON 错误响应。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>默认规则</strong>：Spring Boot 提供了基础的错误处理机制，包括 JSON 错误响应和默认错误页面。</li><li><strong>@ControllerAdvice</strong>：用于处理控制器中的异常，适合需要返回 HTML 错误页面的情况。</li><li><strong>@RestControllerAdvice</strong>：用于处理 RESTful 风格应用中的异常，返回 JSON 格式的错误响应。</li></ul><p>这些功能和注解使得 Spring Boot 能够有效地处理应用中的异常，确保用户获得明确且有用的错误信息。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring-boot </tag>
            
            <tag> 异常处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot整合百度云身份识别</title>
      <link href="/2024/09/01/SpringBoot%E6%95%B4%E5%90%88%E7%99%BE%E5%BA%A6%E4%BA%91%E8%BA%AB%E4%BB%BD%E8%AF%86%E5%88%AB/"/>
      <url>/2024/09/01/SpringBoot%E6%95%B4%E5%90%88%E7%99%BE%E5%BA%A6%E4%BA%91%E8%BA%AB%E4%BB%BD%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="1-登录注册账号"><a href="#1-登录注册账号" class="headerlink" title="1.登录注册账号"></a>1.登录注册账号</h2><p> <a href="https://ai.baidu.com/">百度AI开放平台-全球领先的人工智能服务平台 (baidu.com)</a> </p><h2 id="2-进入官网"><a href="#2-进入官网" class="headerlink" title="2.进入官网"></a>2.进入官网</h2><p><img src="/../images/image-20240830090857037.png"></p><h2 id="3-官网的调用流程"><a href="#3-官网的调用流程" class="headerlink" title="3.官网的调用流程"></a>3.官网的调用流程</h2><p><img src="/../images/image-20240830090920065.png"></p><h2 id="4-免费尝鲜"><a href="#4-免费尝鲜" class="headerlink" title="4.免费尝鲜"></a>4.免费尝鲜</h2><p><img src="/../images/image-20240830091120288.png"></p><h2 id="5-创建应用"><a href="#5-创建应用" class="headerlink" title="5.创建应用"></a>5.创建应用</h2><p><img src="/../images/image-20240830091205560.png"></p><p><img src="/../images/image-20240830091323331.png"></p><h2 id="6-springboot使用"><a href="#6-springboot使用" class="headerlink" title="6.springboot使用"></a>6.springboot使用</h2><h3 id="6-1-导入maven依赖"><a href="#6-1-导入maven依赖" class="headerlink" title="6.1 导入maven依赖"></a>6.1 导入maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-工具类"><a href="#6-2-工具类" class="headerlink" title="6.2 工具类"></a>6.2 工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wf.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.http.HttpUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 身份证识别工具类，提供从百度云获取用户身份证信息的功能</span></span><br><span class="line"><span class="comment"> * 通过调用百度云OCR API，识别并返回身份证上的用户信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mpk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024/8/30 10:10:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdentificationUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 百度云API的Key</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;baiduyun.api-key&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appKey;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 百度云API的Secret Key</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;baiduyun.secret-key&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过百度云OCR服务，识别并获取用户身份证信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file 身份证图片文件的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> idCardSide 身份证的面（正面或反面）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含用户信息的Map，如姓名、民族、地址、身份证号和性别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException 如果文件读取发生错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">getUserInfo</span><span class="params">(<span class="type">byte</span>[] file, String idCardSide)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;id_card_side&quot;</span>, idCardSide);</span><br><span class="line">        map.put(<span class="string">&quot;image&quot;</span>, getFileContentAsBase64(file));</span><br><span class="line">        <span class="type">String</span> <span class="variable">post</span> <span class="operator">=</span> HttpUtil.post(<span class="string">&quot;https://aip.baidubce.com/rest/2.0/ocr/v1/idcard?access_token=&quot;</span> + getAccessToken(), map);</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONUtil.parseObj(post);</span><br><span class="line">        HashMap&lt;String, String&gt; userInfo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (jsonObject.get(<span class="string">&quot;words_result&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">wordsResult</span> <span class="operator">=</span> jsonObject.getJSONObject(<span class="string">&quot;words_result&quot;</span>);</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">nameResult</span> <span class="operator">=</span> wordsResult.getJSONObject(<span class="string">&quot;姓名&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">realName</span> <span class="operator">=</span> (String) nameResult.get(<span class="string">&quot;words&quot;</span>);</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">ethnicGroupResult</span> <span class="operator">=</span> wordsResult.getJSONObject(<span class="string">&quot;民族&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">ethnicGroup</span> <span class="operator">=</span> (String) ethnicGroupResult.get(<span class="string">&quot;words&quot;</span>);</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">addressResult</span> <span class="operator">=</span> wordsResult.getJSONObject(<span class="string">&quot;住址&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> (String) addressResult.get(<span class="string">&quot;words&quot;</span>);</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">idCardResult</span> <span class="operator">=</span> wordsResult.getJSONObject(<span class="string">&quot;公民身份号码&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">idCard</span> <span class="operator">=</span> (String) idCardResult.get(<span class="string">&quot;words&quot;</span>);</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">genderResult</span> <span class="operator">=</span> wordsResult.getJSONObject(<span class="string">&quot;性别&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> (String) genderResult.get(<span class="string">&quot;words&quot;</span>);</span><br><span class="line">            userInfo.put(<span class="string">&quot;realName&quot;</span>, realName);</span><br><span class="line">            userInfo.put(<span class="string">&quot;ethnicGroup&quot;</span>, ethnicGroup);</span><br><span class="line">            userInfo.put(<span class="string">&quot;address&quot;</span>, address);</span><br><span class="line">            userInfo.put(<span class="string">&quot;idCard&quot;</span>, idCard);</span><br><span class="line">            userInfo.put(<span class="string">&quot;gender&quot;</span>, gender);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取文件的Base64编码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b 文件的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 文件内容的Base64编码字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException 如果文件读取发生错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">getFileContentAsBase64</span><span class="params">(<span class="type">byte</span>[] b)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用应用的API Key和Secret Key从百度云获取访问令牌</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 访问百度云API所需的访问令牌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAccessToken</span><span class="params">()</span> &#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;grant_type&quot;</span>, <span class="string">&quot;client_credentials&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;client_id&quot;</span>, appKey);</span><br><span class="line">        map.put(<span class="string">&quot;client_secret&quot;</span>, secretKey);</span><br><span class="line">        <span class="type">String</span> <span class="variable">post</span> <span class="operator">=</span> HttpUtil.post(<span class="string">&quot;https://aip.baidubce.com/oauth/2.0/token&quot;</span>, map);</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONUtil.parseObj(post);</span><br><span class="line">        <span class="keyword">return</span> (String) jsonObject.get(<span class="string">&quot;access_token&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-controller"><a href="#7-controller" class="headerlink" title="7.controller"></a>7.controller</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wf.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wf.constant.MessageConstant;</span><br><span class="line"><span class="keyword">import</span> com.wf.exception.ApartmentException;</span><br><span class="line"><span class="keyword">import</span> com.wf.utils.AliOssUtil;</span><br><span class="line"><span class="keyword">import</span> com.wf.utils.FileNameUtils;</span><br><span class="line"><span class="keyword">import</span> com.wf.utils.IdentificationUtil;</span><br><span class="line"><span class="keyword">import</span> com.wf.vo.Result;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.CrossOrigin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestPart;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件上传接口</span></span><br><span class="line"><span class="comment"> * 处理文件上传相关请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpLoadController</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    IdentificationUtil identificationUtil;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/uploadIdCard&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">uploadIdCard</span><span class="params">(<span class="meta">@RequestPart</span> MultipartFile file)</span> <span class="keyword">throws</span> ApartmentException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        identificationUtil.getUserInfo(file.getBytes(), <span class="string">&quot;front&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-注意"><a href="#8-注意" class="headerlink" title="8.注意"></a>8.注意</h2><p>使用了hutools工具类来简化开发</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 第三方接口 </tag>
            
            <tag> 身份识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniapp整合阿里巴巴矢量图标库</title>
      <link href="/2024/08/29/uniapp%E6%95%B4%E5%90%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%9F%A2%E9%87%8F%E5%9B%BE%E6%A0%87/"/>
      <url>/2024/08/29/uniapp%E6%95%B4%E5%90%88%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E7%9F%A2%E9%87%8F%E5%9B%BE%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h3 id="1-进入官网注册用户"><a href="#1-进入官网注册用户" class="headerlink" title="1.进入官网注册用户"></a>1.进入官网注册用户</h3><p><a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p><h3 id="2-进入我的项目新建项目"><a href="#2-进入我的项目新建项目" class="headerlink" title="2.进入我的项目新建项目"></a>2.进入我的项目新建项目</h3><p><img src="/../images/image-20240829212536040.png"></p><h3 id="3-填写项目信息"><a href="#3-填写项目信息" class="headerlink" title="3.填写项目信息"></a>3.填写项目信息</h3><p><img src="/../images/image-20240829212613062.png"></p><h3 id="4-图标点击购物车"><a href="#4-图标点击购物车" class="headerlink" title="4.图标点击购物车"></a>4.图标点击购物车</h3><p><img src="/../images/image-20240829212654491.png"></p><blockquote></blockquote><h3 id="5-添加进项目中"><a href="#5-添加进项目中" class="headerlink" title="5.添加进项目中"></a>5.添加进项目中</h3><p><img src="/../images/image-20240829212745273.png"></p><p><img src="/../images/image-20240829212749223.png"></p><h3 id="6-生成css文件，网页访问打开它"><a href="#6-生成css文件，网页访问打开它" class="headerlink" title="6.生成css文件，网页访问打开它"></a>6.生成css文件，网页访问打开它</h3><p><img src="/../images/image-20240829212930048.png" alt="image-20240829212930048"></p><h3 id="7-这是源文件"><a href="#7-这是源文件" class="headerlink" title="7.这是源文件"></a>7.这是源文件</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;iconfont&quot;</span>; <span class="comment">/* Project id 4667090 */</span></span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;//at.alicdn.com/t/c/font_4667090_v6rzkfxdvx.woff2?t=1724833352572&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>),</span><br><span class="line">       <span class="built_in">url</span>(<span class="string">&#x27;//at.alicdn.com/t/c/font_4667090_v6rzkfxdvx.woff?t=1724833352572&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>),</span><br><span class="line">       <span class="built_in">url</span>(<span class="string">&#x27;//at.alicdn.com/t/c/font_4667090_v6rzkfxdvx.ttf?t=1724833352572&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.iconfont</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;iconfont&quot;</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span><br><span class="line">  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-bangzhu</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;\e8ac&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><h3 id="8-对文件稍加改造"><a href="#8-对文件稍加改造" class="headerlink" title="8.对文件稍加改造"></a>8.对文件稍加改造</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">        <span class="attribute">font-family</span>: <span class="string">&quot;iconfont&quot;</span>; <span class="comment">/* Project id 4667090 */</span></span><br><span class="line">        <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;//at.alicdn.com/t/c/font_4667090_v6rzkfxdvx.woff2?t=1724833352572&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>),</span><br><span class="line">        <span class="built_in">url</span>(<span class="string">&#x27;//at.alicdn.com/t/c/font_4667090_v6rzkfxdvx.woff?t=1724833352572&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>),</span><br><span class="line">        <span class="built_in">url</span>(<span class="string">&#x27;//at.alicdn.com/t/c/font_4667090_v6rzkfxdvx.ttf?t=1724833352572&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[class^=<span class="string">&#x27;icon-&#x27;</span>]</span>,</span><br><span class="line"><span class="selector-attr">[class*=<span class="string">&#x27; icon-&#x27;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;iconfont&#x27;</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span><br><span class="line">  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"><span class="selector-class">.icon-bangzhu</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;\e8ac&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-在页面中使用"><a href="#9-在页面中使用" class="headerlink" title="9.在页面中使用"></a>9.在页面中使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view class=&quot;icon-bangzhu&quot;&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="10-完工"><a href="#10-完工" class="headerlink" title="10.完工"></a>10.完工</h3>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
            <tag> 图标 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合poi实现对文档编辑并转为pdf</title>
      <link href="/2024/08/29/spring%E6%95%B4%E5%90%88poi/"/>
      <url>/2024/08/29/spring%E6%95%B4%E5%90%88poi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引入maven依赖"><a href="#1-引入maven依赖" class="headerlink" title="1.引入maven依赖"></a>1.引入maven依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">pdfbox.version</span>&gt;</span>2.0.27<span class="tag">&lt;/<span class="name">pdfbox.version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">poi.version</span>&gt;</span>3.17<span class="tag">&lt;/<span class="name">poi.version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xdocreport.version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">xdocreport.version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">documents4j.version</span>&gt;</span>1.0.3<span class="tag">&lt;/<span class="name">documents4j.version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pdfbox.new.version</span>&gt;</span>3.0.0-alpha2<span class="tag">&lt;/<span class="name">pdfbox.new.version</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Apache POI dependencies --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;poi.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml-schemas<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;poi.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;poi.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- XDocReport dependency --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>fr.opensagres.xdocreport<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fr.opensagres.poi.xwpf.converter.pdf-gae<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;xdocreport.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- Documents4J dependencies --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.documents4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>documents4j-local<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;documents4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.documents4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>documents4j-transformer-msoffice-word<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;documents4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- PDF to Image conversion dependencies --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.pdfbox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pdfbox<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pdfbox.new.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.pdfbox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fontbox<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pdfbox.new.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-编写工具类"><a href="#2-编写工具类" class="headerlink" title="2.编写工具类"></a>2.编写工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wf.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.io.resource.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> com.documents4j.api.DocumentType;</span><br><span class="line"><span class="keyword">import</span> com.documents4j.api.IConverter;</span><br><span class="line"><span class="keyword">import</span> com.documents4j.job.LocalConverter;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.pdfbox.Loader;</span><br><span class="line"><span class="keyword">import</span> org.apache.pdfbox.pdmodel.PDDocument;</span><br><span class="line"><span class="keyword">import</span> org.apache.pdfbox.rendering.PDFRenderer;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xwpf.usermodel.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path    模版路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outPath 输出路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dict    需要替换的信息集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2023/2/20 17:42</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Return</span>: boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span>: 根据dict编译模版中的文本和表格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">compile</span><span class="params">(String path, String outPath, Map&lt;String, Object&gt; dict)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPathResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(path);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> resource.getStream();</span><br><span class="line">        <span class="type">XWPFDocument</span> <span class="variable">document</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XWPFDocument</span>(is);</span><br><span class="line">        <span class="keyword">if</span> (dict != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 替换掉表格之外的文本(仅限文本)</span></span><br><span class="line">            WordUtils.compileText(document, dict);</span><br><span class="line">            <span class="comment">// 替换表格内的文本对象</span></span><br><span class="line">            WordUtils.compileTable(document, dict);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(outPath.substring(<span class="number">0</span>, outPath.lastIndexOf(File.separator)));</span><br><span class="line">        <span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">            f.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(outPath);</span><br><span class="line">        document.write(out);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> :替换段落文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> document docx解析对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dict 需要替换的信息集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 2022/11/17 17:22</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">compileText</span><span class="params">(XWPFDocument document, Map&lt;String, Object&gt; dict)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取段落集合</span></span><br><span class="line">        Iterator&lt;XWPFParagraph&gt; iterator = document.getParagraphsIterator();</span><br><span class="line">        XWPFParagraph paragraph;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            paragraph = iterator.next();</span><br><span class="line">            <span class="comment">// 判断此段落是否需要替换</span></span><br><span class="line">            <span class="keyword">if</span> (checkText(paragraph.getText())) &#123;</span><br><span class="line">                replaceValue(paragraph, dict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> :替换表格内的文字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> document</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dict 需要替换的信息集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 2022/11/18 11:29</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">compileTable</span><span class="params">(XWPFDocument document, Map&lt;String, Object&gt; dict)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取文件的表格</span></span><br><span class="line">        Iterator&lt;XWPFTable&gt; tableList = document.getTablesIterator();</span><br><span class="line">        XWPFTable table;</span><br><span class="line">        List&lt;XWPFTableRow&gt; rows;</span><br><span class="line">        List&lt;XWPFTableCell&gt; cells;</span><br><span class="line">        <span class="comment">// 循环所有需要进行替换的文本，进行替换</span></span><br><span class="line">        <span class="keyword">while</span> (tableList.hasNext()) &#123;</span><br><span class="line">            table = tableList.next();</span><br><span class="line">            <span class="keyword">if</span> (checkText(table.getText())) &#123;</span><br><span class="line">                rows = table.getRows();</span><br><span class="line">                <span class="comment">// 遍历表格，并替换模板</span></span><br><span class="line">                <span class="keyword">for</span> (XWPFTableRow row : rows) &#123;</span><br><span class="line">                    cells = row.getTableCells();</span><br><span class="line">                    <span class="keyword">for</span> (XWPFTableCell cell : cells) &#123;</span><br><span class="line">                        <span class="comment">// 判断单元格是否需要替换</span></span><br><span class="line">                        <span class="keyword">if</span> (checkText(cell.getText())) &#123;</span><br><span class="line">                            List&lt;XWPFParagraph&gt; paragraphs = cell.getParagraphs();</span><br><span class="line">                            <span class="keyword">for</span> (XWPFParagraph paragraph : paragraphs) &#123;</span><br><span class="line">                                replaceValue(paragraph, dict);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paragraph word文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dict      需要替换的信息集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 2023/2/20 17:31</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span>: 替换字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">replaceValue</span><span class="params">(XWPFParagraph paragraph, Map&lt;String, Object&gt; dict)</span> &#123;</span><br><span class="line">        String nextLine;</span><br><span class="line">        paragraph.setStyle(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        List&lt;XWPFRun&gt; runs = paragraph.getRuns();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; runs.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 读取当前行</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">readLine</span> <span class="operator">=</span> runs.get(i).text();</span><br><span class="line"><span class="comment">//            System.out.println(&quot;readLine:&quot; + readLine);</span></span><br><span class="line">            <span class="comment">// 如果为空 或 不包含目标字符串 则跳过</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(readLine) || !readLine.contains(<span class="string">&quot;$&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 初始化结果集</span></span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环处理当前行的模版串</span></span><br><span class="line">            <span class="keyword">if</span> (readLine.contains(<span class="string">&quot;$&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 获取模版串左侧字符串</span></span><br><span class="line">                <span class="type">int</span> left;</span><br><span class="line">                <span class="keyword">if</span> (readLine.contains(<span class="string">&quot;$&#123;&quot;</span>)) &#123;</span><br><span class="line">                    left = readLine.indexOf(<span class="string">&quot;$&#123;&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (runs.size() &lt; i + <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextLine = runs.get(i + <span class="number">1</span>).text();</span><br><span class="line">                    <span class="keyword">if</span> (!nextLine.startsWith(<span class="string">&quot;&#123;&quot;</span>)) <span class="keyword">break</span>;</span><br><span class="line">                    readLine += nextLine;</span><br><span class="line">                    paragraph.removeRun(i + <span class="number">1</span>);</span><br><span class="line">                    left = readLine.indexOf(<span class="string">&quot;$&#123;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(readLine.substring(<span class="number">0</span>, left));</span><br><span class="line">                <span class="comment">// 获取模版串右侧</span></span><br><span class="line">                <span class="keyword">while</span> (runs.size() &gt;= i + <span class="number">1</span> &amp;&amp; !readLine.contains(<span class="string">&quot;&#125;&quot;</span>)) &#123;</span><br><span class="line">                    nextLine = runs.get(i + <span class="number">1</span>).text();</span><br><span class="line">                    readLine += nextLine;</span><br><span class="line">                    paragraph.removeRun(i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> readLine.indexOf(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (right == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 替换模版串 [如果字典中不存在,不替换]</span></span><br><span class="line">                sb.append(dict.getOrDefault(readLine.substring(left, right + <span class="number">1</span>), readLine));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (right + <span class="number">1</span> &lt; readLine.length()) &#123;</span><br><span class="line">                    sb.append(readLine.substring(right + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果字符串中包含$ 将颜色改为白色</span></span><br><span class="line">            <span class="keyword">if</span>(WordUtils.checkText(sb.toString()))</span><br><span class="line">            &#123;</span><br><span class="line">                runs.get(i).setColor(<span class="string">&quot;ffffff&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                runs.get(i).setColor(<span class="string">&quot;f56026&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            runs.get(i).setText(sb.toString(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> :检查文本中是否包含指定的字符(此处为“$”)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 2022/11/17 17:22</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkText</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> text.contains(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过documents4j 实现word转pdf</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourcePath 源文件地址 如 /root/example.doc</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetPath 目标文件地址 如 /root/example.pdf</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">documents4jWordToPdf</span><span class="params">(String sourcePath, String targetPath)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">inputWord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(sourcePath);</span><br><span class="line">        <span class="type">File</span> <span class="variable">outputFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(targetPath);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">docxInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(inputWord);</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(outputFile);</span><br><span class="line">            <span class="type">IConverter</span> <span class="variable">converter</span> <span class="operator">=</span> LocalConverter.builder().build();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">execute</span> <span class="operator">=</span> converter.convert(docxInputStream)</span><br><span class="line">                    .as(DocumentType.DOCX)</span><br><span class="line">                    .to(outputStream)</span><br><span class="line">                    .as(DocumentType.PDF).schedule().get();</span><br><span class="line">            outputStream.close();</span><br><span class="line">            docxInputStream.close();</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;转换完毕 targetPath = &#123;&#125;&quot;</span>, outputFile.getAbsolutePath());</span><br><span class="line">            System.out.println(<span class="string">&quot;转换完毕 targetPath = &quot;</span> + outputFile.getAbsolutePath());</span><br><span class="line">            converter.shutDown();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;[documents4J] word转pdf失败:&#123;&#125;&quot;</span>, e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将生成的 Word 文档转换为 PDF 格式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> wordPath Word 文档路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pdfPath  生成的 PDF 路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">convertToPDF</span><span class="params">(String wordPath, String pdfPath)</span> &#123;</span><br><span class="line">        documents4jWordToPdf(wordPath, pdfPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PDF文件转图片</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourcePath PDF文件地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String sourcePath)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(sourcePath);</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> file.getAbsolutePath();</span><br><span class="line">        <span class="type">String</span> <span class="variable">targetPathNoExt</span> <span class="operator">=</span> path.substring(<span class="number">0</span>, path.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">PDDocument</span> <span class="variable">doc</span> <span class="operator">=</span> Loader.loadPDF(file);</span><br><span class="line">            <span class="type">PDFRenderer</span> <span class="variable">renderer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PDFRenderer</span>(doc);</span><br><span class="line">            <span class="type">int</span> <span class="variable">pageCount</span> <span class="operator">=</span> doc.getNumberOfPages();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pageCount; i++) &#123;</span><br><span class="line">                <span class="comment">// System.out.println(&quot;当前页面&quot; + (i + 1));</span></span><br><span class="line">                <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> renderer.renderImageWithDPI(i, <span class="number">296</span>);</span><br><span class="line">                <span class="comment">// BufferedImage image = renderer.renderImage(i, 2.5f);</span></span><br><span class="line">                ImageIO.write(image, <span class="string">&quot;PNG&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(targetPathNoExt + <span class="string">&quot;_&quot;</span> + i + <span class="string">&quot;.png&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-编写文档模版"><a href="#3-编写文档模版" class="headerlink" title="3.编写文档模版"></a>3.编写文档模版</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">租房合同</span><br><span class="line">1. 合同双方</span><br><span class="line">出租方（甲方）</span><br><span class="line">姓名/公司名称：$&#123;landlordName&#125;</span><br><span class="line">地址：$&#123;landlordAddress&#125;</span><br><span class="line">联系方式：$&#123;landlordPhone&#125;</span><br><span class="line">承租方（乙方）</span><br><span class="line">姓名：$&#123;tenantName&#125;</span><br><span class="line">身份证号：$&#123;tenantIdCard&#125;</span><br><span class="line">地址：$&#123;tenantAddress&#125;</span><br><span class="line">联系方式：$&#123;tenantPhone&#125;</span><br><span class="line">2. 房屋基本情况</span><br><span class="line">房屋位置 :  $&#123;houseLocation&#125;</span><br><span class="line">房屋面积：$&#123;houseArea&#125;</span><br><span class="line">房屋结构：$&#123;houseStructure&#125;</span><br><span class="line">公共设施：$&#123;publicFacilities&#125;</span><br><span class="line">能源设施：$&#123;energyFacilities&#125;</span><br><span class="line">3. 租赁期限</span><br><span class="line">开始日期：$&#123;startDate&#125;</span><br><span class="line">结束日期：$&#123;endDate&#125;</span><br><span class="line">租期总计：$&#123;totalLeasePeriod&#125;</span><br><span class="line">4. 租金及支付方式</span><br><span class="line">每月租金：$&#123;monthlyRent&#125;</span><br><span class="line">支付周期：$&#123;paymentCycle&#125;</span><br><span class="line">支付方式：在线支付</span><br><span class="line">5. 房屋使用规定</span><br><span class="line">使用目的：乙方租赁该房屋仅用于居住用途，不得用作商业、办公或其他非法活动。</span><br><span class="line">维护责任：乙方应妥善使用并维护房屋及其配套设施，如因乙方原因造成损坏，乙方需承担修复费用。</span><br><span class="line">禁止行为：</span><br><span class="line">不得擅自改变房屋结构或装修；</span><br><span class="line">不得将房屋转租给第三方；</span><br><span class="line">不得从事违法活动；</span><br><span class="line">不得饲养宠物。</span><br><span class="line">其他约定：</span><br><span class="line">乙方应按时缴纳水、电、燃气等费用；</span><br><span class="line">未经甲方同意，乙方不得擅自安装或拆除房屋内的设备设施。</span><br><span class="line">6. 违约责任</span><br><span class="line">违约情形：</span><br><span class="line">乙方未按约定支付租金；</span><br><span class="line">乙方违反使用规定；</span><br><span class="line">甲方未按约定提供房屋或配套设施。</span><br><span class="line">违约金计算方法：</span><br><span class="line">若乙方逾期支付租金，每逾期一天需支付相当于日租金的滞纳金；</span><br><span class="line">若乙方违反使用规定，需支付违约金人民币 5000 元；</span><br><span class="line">若甲方未按约定提供房屋或配套设施，需退还相应租金并支付违约金人民币 5000 元。</span><br><span class="line">解决争议的方式：</span><br><span class="line">双方应首先通过友好协商解决争议；</span><br><span class="line">如协商不成，可提交至房屋所在地人民法院诉讼解决。</span><br><span class="line">7. 合同变更与解除</span><br><span class="line">变更条件：</span><br><span class="line">双方协商一致后可对合同进行变更；</span><br><span class="line">变更内容需书面形式确认。</span><br><span class="line">解除条件：</span><br><span class="line">一方严重违约，经催告仍不改正；</span><br><span class="line">因不可抗力导致合同无法履行。</span><br><span class="line">提前终止合同的处理办法：</span><br><span class="line">任何一方要求提前终止合同，需提前一个月书面通知对方；</span><br><span class="line">提前终止合同的一方需支付违约金人民币 5000 元。</span><br><span class="line">8. 附则</span><br><span class="line">本合同自双方签字盖章之日起生效。</span><br><span class="line">本合同一式两份，甲乙双方各执一份，具有同等法律效力。</span><br><span class="line">其他补充条款：</span><br><span class="line">甲方应在乙方入住前提供房屋钥匙及相关设施的使用说明；</span><br><span class="line">乙方应遵守小区物业管理规定。</span><br><span class="line">希望这些内容能帮助您更好地制定租房合同。如果有其他需求或修改，请随时告知。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-编写测试类"><a href="#4-编写测试类" class="headerlink" title="4.编写测试类"></a>4.编写测试类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.date.DatePattern;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.date.DateUtil;</span><br><span class="line"><span class="keyword">import</span> com.wf.dto.ContractDTO;</span><br><span class="line"><span class="keyword">import</span> com.wf.dto.ContractMap;</span><br><span class="line"><span class="keyword">import</span> com.wf.utils.WordUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mpk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024/8/29 13:23:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UtilsTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ContractDTO</span> <span class="variable">dto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContractDTO</span>();</span><br><span class="line">        dto.setLandlordName(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        dto.setLandlordPhone(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">        dto.setLandlordAddress(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">        dto.setTenantName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        dto.setTenantPhone(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">        dto.setTenantAddress(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        dto.setTenantIdCard(<span class="string">&quot;123456789012345678&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dto.setHouseArea(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        dto.setPublicFacilities(<span class="string">&quot;无&quot;</span>);</span><br><span class="line">        dto.setEnergyFacilities(<span class="string">&quot;无&quot;</span>);</span><br><span class="line"></span><br><span class="line">        dto.setStartDate(DateUtil.format(DateUtil.parse(<span class="string">&quot;2024-08-29&quot;</span>), DatePattern.NORM_DATE_PATTERN));</span><br><span class="line">        dto.setEndDate(DateUtil.format(DateUtil.parse(<span class="string">&quot;2024-08-29&quot;</span>), DatePattern.NORM_DATE_PATTERN));</span><br><span class="line">        dto.setTotalLeasePeriod(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        dto.setPaymentCycle(<span class="string">&quot;月&quot;</span>);</span><br><span class="line">        dto.setMonthlyRent(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line">        <span class="type">ContractMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ContractMap</span>(dto);</span><br><span class="line">        <span class="type">String</span> <span class="variable">readPath</span> <span class="operator">=</span> <span class="string">&quot;template/contractTemplate.docx&quot;</span>; <span class="comment">//word模板</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">outPath</span> <span class="operator">=</span> <span class="string">&quot;E:\\output1.docx&quot;</span>; <span class="comment">//输出填充word路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">outPdfPath</span> <span class="operator">=</span> <span class="string">&quot;E:\\output1.pdf&quot;</span>; <span class="comment">//输入word转pdf路径</span></span><br><span class="line"></span><br><span class="line">        WordUtils.compile(readPath, outPath, map); <span class="comment">//填充word，如果只要word转pdf这里可以不要</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换操作，可单独使用</span></span><br><span class="line">        WordUtils.convertToPDF(outPath,outPdfPath); <span class="comment">//word转pdf</span></span><br><span class="line">        WordUtils.execute(outPdfPath); <span class="comment">//pdf转图片png</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring-boot </tag>
            
            <tag> poi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云OSS</title>
      <link href="/2024/08/26/%E9%98%BF%E9%87%8COSS/"/>
      <url>/2024/08/26/%E9%98%BF%E9%87%8COSS/</url>
      
        <content type="html"><![CDATA[<h2 id="阿里云-OSS"><a href="#阿里云-OSS" class="headerlink" title="阿里云 OSS"></a>阿里云 OSS</h2><h3 id="1-进入官网"><a href="#1-进入官网" class="headerlink" title="1. 进入官网"></a>1. 进入官网</h3><p>访问阿里云官方网站以获取更多信息和资源：<a href="https://cn.aliyun.com/">阿里云官网</a></p><h3 id="2-注册阿里账号并进行实名认证"><a href="#2-注册阿里账号并进行实名认证" class="headerlink" title="2. 注册阿里账号并进行实名认证"></a>2. 注册阿里账号并进行实名认证</h3><p>在官网上注册账号，并完成实名认证以获得阿里云服务的访问权限。</p><h3 id="3-查看-API-文档"><a href="#3-查看-API-文档" class="headerlink" title="3. 查看 API 文档"></a>3. 查看 API 文档</h3><p>查看阿里云 OSS 的 API 文档以了解详细的使用方法和接口信息：<a href="https://help.aliyun.com/zh/oss/getting-started/getting-started-with-oss?spm=a2c4g.11186623.0.0.3a1197f0kBdrpT#section-0bb-c7c-qsn">OSS 快速入门</a></p><h3 id="4-控制台操作流程"><a href="#4-控制台操作流程" class="headerlink" title="4. 控制台操作流程"></a>4. 控制台操作流程</h3><p>查看详细的控制台操作流程：<a href="https://help.aliyun.com/zh/oss/getting-started/console-quick-start?spm=a2c4g.11186623.0.0.43f123bfXADCbw">控制台快速入门</a></p><h4 id="4-1-开通-OSS-服务"><a href="#4-1-开通-OSS-服务" class="headerlink" title="4.1 开通 OSS 服务"></a>4.1 开通 OSS 服务</h4><p>在阿里云控制台中开通 OSS 服务。</p><p><img src="/../images/image-20240821135754161.png" alt="image-20240821135754161"></p><h4 id="4-2-创建存储空间"><a href="#4-2-创建存储空间" class="headerlink" title="4.2 创建存储空间"></a>4.2 创建存储空间</h4><p>在 OSS 控制台中创建存储空间（Bucket）。</p><p><img src="/../images/image-20240821135823281.png" alt="image-20240821135823281"></p><p><img src="/../images/image-20240821135857614.png" alt="image-20240821135857614"></p><h4 id="4-3-上传文件"><a href="#4-3-上传文件" class="headerlink" title="4.3 上传文件"></a>4.3 上传文件</h4><p>使用 OSS 控制台上传文件到创建的存储空间。</p><p><img src="/../images/image-20240821140010020.png" alt="image-20240821140010020"></p><p><img src="/../images/image-20240821140048790.png" alt="image-20240821140048790"></p><h3 id="5-使用-Java-SDK-操作流程"><a href="#5-使用-Java-SDK-操作流程" class="headerlink" title="5. 使用 Java SDK 操作流程"></a>5. 使用 Java SDK 操作流程</h3><h4 id="5-1-安装-SDK"><a href="#5-1-安装-SDK" class="headerlink" title="5.1 安装 SDK"></a>5.1 安装 SDK</h4><p>从阿里云官方网站下载并安装 Java SDK。</p><p>在Maven工程中使用OSS Java SDK，只需在pom.xml中加入相应依赖即可。以在<dependencies>中加入3.17.4版本的依赖为例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.17.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用的是Java 9及以上的版本，则需要添加JAXB相关依赖。添加JAXB相关依赖示例代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- no more than 2.3.3--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-2-配置访问凭证"><a href="#5-2-配置访问凭证" class="headerlink" title="5.2 配置访问凭证"></a>5.2 配置访问凭证</h4><h5 id="5-2-1-创建用户"><a href="#5-2-1-创建用户" class="headerlink" title="5.2.1 创建用户"></a>5.2.1 创建用户</h5><p>在控制台中创建用户，并为用户分配相应的权限。</p><p><img src="/../images/image-20240821140127124.png" alt="image-20240821140127124"></p><p><img src="/../images/image-20240821140609284.png" alt="image-20240821140609284"></p><p><img src="/../images/image-20240821140502090.png" alt="image-20240821140502090"></p><p><img src="/../images/image-20240821140644817.png" alt="image-20240821140644817"></p><h5 id="5-2-2-创建-ACCESS-KEY"><a href="#5-2-2-创建-ACCESS-KEY" class="headerlink" title="5.2.2 创建 ACCESS_KEY"></a>5.2.2 创建 ACCESS_KEY</h5><p>为用户生成 ACCESS_KEY，用于访问 OSS 服务。</p><p><img src="/../images/image-20240821140711652.png" alt="image-20240821140711652"></p><p><img src="/../images/image-20240821140828601.png" alt="image-20240821140828601"></p><h5 id="5-2-3-配置环境变量"><a href="#5-2-3-配置环境变量" class="headerlink" title="5.2.3 配置环境变量"></a>5.2.3 配置环境变量</h5><p>设置环境变量以方便在代码中使用 ACCESS_KEY：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setx OSS_ACCESS_KEY_ID &lt;ALIBABA_CLOUD_ACCESS_KEY_ID&gt;</span><br><span class="line">setx OSS_ACCESS_KEY_SECRET &lt;ALIBABA_CLOUD_ACCESS_KEY_SECRET&gt;</span><br></pre></td></tr></table></figure><h5 id="5-2-4-测试环境变量"><a href="#5-2-4-测试环境变量" class="headerlink" title="5.2.4 测试环境变量"></a>5.2.4 测试环境变量</h5><p>通过以下 Java 代码测试环境变量是否设置成功：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEnv</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(System.getenv(<span class="string">&quot;OSS_ACCESS_KEY_ID&quot;</span>));</span><br><span class="line">        System.out.println(System.getenv(<span class="string">&quot;OSS_ACCESS_KEY_SECRET&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-5-测试代码"><a href="#5-2-5-测试代码" class="headerlink" title="5.2.5 测试代码"></a>5.2.5 测试代码</h4><p>以下是一个使用 Java SDK 访问 OSS 的示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.aliyun.oss.ClientException;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSS;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSSClientBuilder;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.OSSException;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.common.auth.CredentialsProviderFactory;</span><br><span class="line"><span class="keyword">import</span> com.aliyun.oss.common.auth.EnvironmentVariableCredentialsProvider;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 设置 Endpoint，以下示例以华东1（杭州）为例。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> <span class="string">&quot;https://oss-cn-hangzhou.aliyuncs.com&quot;</span>;</span><br><span class="line">        <span class="comment">// 从环境变量中获取访问凭证。请确保已设置环境变量 OSS_ACCESS_KEY_ID 和 OSS_ACCESS_KEY_SECRET。</span></span><br><span class="line">        <span class="type">EnvironmentVariableCredentialsProvider</span> <span class="variable">credentialsProvider</span> <span class="operator">=</span> CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider();</span><br><span class="line">        <span class="comment">// 填写 Bucket 名称，例如 examplebucket。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">bucketName</span> <span class="operator">=</span> <span class="string">&quot;examplebucket&quot;</span>;</span><br><span class="line">        <span class="comment">// 填写 Object 完整路径，例如 exampledir/exampleobject.txt。路径中不能包含 Bucket 名称。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> <span class="string">&quot;exampledir/exampleobject.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 OSSClient 实例。</span></span><br><span class="line">        <span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, credentialsProvider);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;Hello OSS&quot;</span>;</span><br><span class="line">            <span class="comment">// 上传对象到 OSS。</span></span><br><span class="line">            ossClient.putObject(bucketName, objectName, <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(content.getBytes()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OSSException oe) &#123;</span><br><span class="line">            <span class="comment">// 捕获 OSS 异常。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Caught an OSSException, which means your request made it to OSS, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;but was rejected with an error response for some reason.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Message:&quot;</span> + oe.getErrorMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Code:&quot;</span> + oe.getErrorCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;Request ID:&quot;</span> + oe.getRequestId());</span><br><span class="line">            System.out.println(<span class="string">&quot;Host ID:&quot;</span> + oe.getHostId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException ce) &#123;</span><br><span class="line">            <span class="comment">// 捕获客户端异常。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Caught a ClientException, which means the client encountered &quot;</span></span><br><span class="line">                    + <span class="string">&quot;a serious internal problem while trying to communicate with OSS, &quot;</span></span><br><span class="line">                    + <span class="string">&quot;such as not being able to access the network.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Error Message:&quot;</span> + ce.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ossClient != <span class="literal">null</span>) &#123;</span><br><span class="line">                ossClient.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 第三方接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot各种注解</title>
      <link href="/2024/08/20/SpringBoot%E5%90%84%E7%A7%8D%E6%B3%A8%E8%A7%A3/"/>
      <url>/2024/08/20/SpringBoot%E5%90%84%E7%A7%8D%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-底层注解"><a href="#1-底层注解" class="headerlink" title="1. 底层注解"></a>1. 底层注解</h2><p>以下是统一格式的注解说明，涵盖 Spring Boot 中的主要注解及其用途、示例和配置：</p><h3 id="1-1-基础注解"><a href="#1-1-基础注解" class="headerlink" title="1.1 基础注解"></a>1.1 基础注解</h3><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a><code>@SpringBootApplication</code></h4><ul><li><p><strong>说明</strong>: 这是一个复合注解，包含了 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>。它是启动 Spring Boot 应用的入口注解。</p></li><li><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a><code>@Configuration</code></h4><ul><li><p><strong>说明</strong>: 用于定义 Spring 配置类，表示该类包含一个或多个 <code>@Bean</code> 方法，用于定义 Bean。</p></li><li><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a><code>@Component</code></h4><ul><li><p><strong>说明</strong>: 表示一个 Spring 管理的组件，通常用于自动扫描和注册 Bean。</p></li><li><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="comment">// Component implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a><code>@Bean</code></h4><ul><li><p><strong>说明</strong>: 用于在配置类中定义一个 Bean。</p></li><li><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-1-配置属性注解"><a href="#2-1-配置属性注解" class="headerlink" title="2.1 配置属性注解"></a>2.1 配置属性注解</h3><h4 id="EnableConfigurationProperties"><a href="#EnableConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties"></a><code>@EnableConfigurationProperties</code></h4><ul><li><p><strong>说明</strong>: 启用对 <code>@ConfigurationProperties</code> 注解的支持，允许 Spring Boot 自动将配置文件中的属性映射到 Bean 的字段中。</p></li><li><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MyProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;my&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件 <code>application.properties</code>：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">my.name</span>=<span class="string">John Doe</span></span><br><span class="line"><span class="attr">my.age</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a><code>@ConfigurationProperties</code></h4><ul><li><p><strong>说明</strong>: 用于将配置文件中的属性绑定到 Java 类上，通常和 <code>@EnableConfigurationProperties</code> 一起使用。</p></li><li><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;my&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件 <code>application.properties</code>：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">my.name</span>=<span class="string">John Doe</span></span><br><span class="line"><span class="attr">my.age</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="3-1条件化配置注解"><a href="#3-1条件化配置注解" class="headerlink" title="3. 1条件化配置注解"></a>3. 1条件化配置注解</h3><h4 id="Condition"><a href="#Condition" class="headerlink" title="@Condition"></a><code>@Condition</code></h4><ul><li><p><strong>说明</strong>: <code>@Condition</code> 是一个用于条件化配置的注解。它通常配合 <code>@Conditional</code> 使用，用于在特定条件下启用或禁用配置类或 Bean。</p></li><li><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;my.feature.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeatureConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyFeature <span class="title function_">myFeature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyFeature</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件中的条件：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">my.feature.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a><code>@Import</code></h4><ul><li><p><strong>说明</strong>: 用于将其他配置类导入当前配置类中。这使得可以在不同的配置类中组织和管理 Bean 定义。</p></li><li><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(AdditionalConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span> &#123;</span><br><span class="line">    <span class="comment">// Main configuration</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdditionalConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AnotherService <span class="title function_">anotherService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnotherService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="AutoConfiguration"><a href="#AutoConfiguration" class="headerlink" title="@AutoConfiguration"></a><code>@AutoConfiguration</code></h4><ul><li><p><strong>说明</strong>: 这是 Spring Boot 的核心注解之一，自动配置类可以帮助 Spring Boot 根据类路径中的库、项目的其他 Bean 定义等来自动配置应用程序。</p></li><li><p><strong>示例</strong>: 通常不需要显式使用该注解，因为 Spring Boot 启动类中的 <code>@SpringBootApplication</code> 注解已经包含了 <code>@EnableAutoConfiguration</code>。</p></li></ul><hr><h3 id="4-1-条件性创建-Bean"><a href="#4-1-条件性创建-Bean" class="headerlink" title="4.1 条件性创建 Bean"></a>4.1 条件性创建 Bean</h3><h4 id="Conditional-和-ConditionalOnProperty"><a href="#Conditional-和-ConditionalOnProperty" class="headerlink" title="@Conditional 和 @ConditionalOnProperty"></a><code>@Conditional</code> 和 <code>@ConditionalOnProperty</code></h4><ul><li><p><strong>说明</strong>: <code>@Conditional</code> 是一个更底层的注解，允许基于不同条件创建 Bean。<code>@ConditionalOnProperty</code> 是常用的条件注解之一，用于基于配置文件中的属性来条件性地创建 Bean。</p></li><li><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;my.feature.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionalConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ConditionalService <span class="title function_">conditionalService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionalService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p>以上注解是 Spring Boot 中常用的底层注解，涵盖了应用启动、配置、条件化和组件管理等功能。</p><h3 id="2-IOC-注解"><a href="#2-IOC-注解" class="headerlink" title="2. IOC 注解"></a>2. IOC 注解</h3><p>这些注解用于控制反转（IoC），主要涉及 Bean 的管理和依赖注入。</p><ul><li><p><strong><code>@Autowired</code></strong>  </p><ul><li><strong>说明</strong>: 自动注入依赖项。Spring 会根据类型自动注入对应的 Bean。</li><li><strong>示例</strong>:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use myService</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>@Qualifier</code></strong>  </p><ul><li><strong>说明</strong>: 与 <code>@Autowired</code> 一起使用，指定要注入的具体 Bean，解决多个 Bean 的歧义问题。</li><li><strong>示例</strong>:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;specificService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// use myService</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>@Resource</code></strong>  </p><ul><li><p><strong>说明</strong>: 根据名称注入 Bean，主要用于根据 Bean 的名字注入。</p></li><li><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@Component</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">      <span class="meta">@Resource(name = &quot;myService&quot;)</span></span><br><span class="line">      <span class="keyword">private</span> MyService myService;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// use myService</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>@PostConstruct</code></strong>  </p><ul><li><p><strong>说明</strong>: 用于标记一个初始化方法，在依赖注入完成后调用。</p></li><li><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// initialization logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>@PreDestroy</code></strong>  </p><ul><li><strong>说明</strong>: 用于标记一个销毁方法，在 Bean 被销毁之前调用。</li><li><strong>示例</strong>:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// cleanup logic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-Controller-参数注解"><a href="#3-Controller-参数注解" class="headerlink" title="3. Controller 参数注解"></a>3. Controller 参数注解</h3><p>这些注解主要用于处理请求并传递参数给控制器的方法。</p><ul><li><p><strong><code>@RestController</code></strong>  </p><ul><li><p><strong>说明</strong>: 是 <code>@Controller</code> 和 <code>@ResponseBody</code> 的组合，表示这个类是一个控制器，并且所有的方法都以 JSON 或 XML 的形式返回数据。</p></li><li><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><strong><code>@RequestMapping</code></strong>  </p><ul><li><strong>说明</strong>: 用于定义请求的 URL 路径和方法类型（GET、POST 等）。</li><li><strong>示例</strong>:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/greet&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Greetings!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>@GetMapping</code></strong>  </p><ul><li><strong>说明</strong>: 用于处理 HTTP GET 请求的快捷方式。</li><li><strong>示例</strong>:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>@PostMapping</code></strong>  </p><ul><li><strong>说明</strong>: 用于处理 HTTP POST 请求的快捷方式。</li><li><strong>示例</strong>:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/submit&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">submit</span><span class="params">(<span class="meta">@RequestBody</span> MyData data)</span> &#123;</span><br><span class="line">        <span class="comment">// handle data</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Data submitted!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>@RequestParam</code></strong>  </p><ul><li><p><strong>说明</strong>: 用于从请求参数中提取值，并将其绑定到方法参数。</p></li><li><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="meta">@RestController</span></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">      <span class="meta">@GetMapping(&quot;/greet&quot;)</span></span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">greet</span><span class="params">(<span class="meta">@RequestParam(name = &quot;name&quot;, defaultValue = &quot;Guest&quot;)</span> String name)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>@RequestPart</code></strong> 是 Spring Framework 中用于处理 multipart&#x2F;form-data 请求的注解，通常用于文件上传或复杂的表单数据。它通常与 <code>@PostMapping</code> 或 <code>@RequestMapping</code> 一起使用，用于将请求体中的部分数据绑定到方法参数上。这个注解使得处理文件和表单数据变得更加简单和直接。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><strong>文件上传</strong>: <code>@RequestPart</code> 可以用来绑定上传的文件。</li><li><strong>复杂表单数据</strong>: 如果请求体包含多个部分，例如文件和 JSON 数据，<code>@RequestPart</code> 可以用来处理这些不同的部分。</li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>假设我们有一个上传文件和一些其他表单数据的场景。我们可以定义一个 REST 控制器方法来处理这个请求。</p><h4 id="上传文件和额外的表单数据"><a href="#上传文件和额外的表单数据" class="headerlink" title="上传文件和额外的表单数据"></a>上传文件和额外的表单数据</h4></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaimport org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestPart;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleFileUpload</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestPart(&quot;file&quot;)</span> MultipartFile file,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestPart(&quot;description&quot;)</span> String description)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">        <span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> file.getSize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理描述</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Description: &quot;</span> + description);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回响应</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;File &quot;</span> + fileName + <span class="string">&quot; with size &quot;</span> + fileSize + <span class="string">&quot; and description &quot;</span> + description + <span class="string">&quot; uploaded successfully!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>@PathVariable</code></strong>  </p><ul><li><strong>说明</strong>: 用于从 URL 路径中提取值，并将其绑定到方法参数。</li><li><strong>示例</strong>:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User ID: &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>@RequestBody</code></strong>  </p><ul><li><strong>说明</strong>: 用于将请求体中的数据绑定到方法参数上，通常用于处理 POST 请求中的 JSON 数据。</li><li><strong>示例</strong>:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/create&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">create</span><span class="params">(<span class="meta">@RequestBody</span> MyData data)</span> &#123;</span><br><span class="line">        <span class="comment">// handle data</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Data created!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>@ResponseBody</code></strong>  </p><ul><li><strong>说明</strong>: 表示方法的返回值应该直接绑定到 HTTP 响应体中，通常用于返回 JSON 或 XML 数据。</li><li><strong>示例</strong>:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/data&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> MyData <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4-Spring-MVC与Spring-Boot的区别"><a href="#4-Spring-MVC与Spring-Boot的区别" class="headerlink" title="4. Spring MVC与Spring Boot的区别"></a>4. Spring MVC与Spring Boot的区别</h3><p><strong>Spring MVC</strong> 和 <strong>Spring Boot</strong> 都是Spring框架的一部分，但它们各自的用途和功能有所不同。</p><ul><li><p><strong>Spring MVC</strong>:</p><ul><li><strong>定义</strong>: 是Spring框架的一部分，主要用于构建Web应用程序。它基于MVC（Model-View-Controller）设计模式，提供了一个分层的架构来开发Web应用。</li><li><strong>功能</strong>: 提供了控制器、视图解析器、数据绑定等功能。它专注于Web层的开发，并且需要开发者自行配置各种组件和设置。</li><li><strong>配置</strong>: 配置通常较为繁琐，涉及大量的XML配置文件或者Java配置类。</li><li><strong>应用</strong>: 适用于需要灵活控制的传统Web应用项目，特别是那些需要手动配置各种组件的项目。</li></ul></li><li><p><strong>Spring Boot</strong>:</p><ul><li><strong>定义</strong>: 是一个基于Spring的开源框架，用于简化Spring应用的创建和部署。它提供了一种开箱即用的解决方案，减少了大量的配置和样板代码。</li><li><strong>功能</strong>: 提供了自动配置、内嵌服务器（如Tomcat、Jetty）、生产级别的特性（如监控和管理），使开发人员可以专注于业务逻辑，而不必担心基础设施的配置。</li><li><strong>配置</strong>: 提供了默认配置和自动配置，减少了手动配置的需求。使用<code>application.properties</code>或<code>application.yml</code>文件进行配置，使得项目设置更加简洁。</li><li><strong>应用</strong>: 适用于快速开发和部署，尤其是微服务架构和新建项目，因为它可以减少项目启动时间和开发过程中的配置复杂性。</li></ul></li></ul><h3 id="5-Autowired-Qualifier-和-Resource的区别"><a href="#5-Autowired-Qualifier-和-Resource的区别" class="headerlink" title="5. @Autowired, @Qualifier 和 @Resource的区别"></a>5. @Autowired, @Qualifier 和 @Resource的区别</h3><p>这些注解都是用于依赖注入的，但它们在使用和功能上有所不同：</p><ul><li><p><strong>@Autowired</strong>:</p><ul><li><strong>定义</strong>: 是Spring框架提供的注解，用于自动注入Bean。</li><li><strong>功能</strong>: 自动根据类型注入Bean。如果Spring容器中有多个符合条件的Bean，可能会导致<code>NoUniqueBeanDefinitionException</code>异常。</li><li><strong>使用</strong>: 可以用于构造函数、方法、字段等。可选地结合<code>@Qualifier</code>使用，以指定注入的具体Bean。</li></ul></li><li><p><strong>@Qualifier</strong>:</p><ul><li><strong>定义</strong>: 是Spring框架提供的注解，用于在使用<code>@Autowired</code>时，指定注入的Bean的名称。</li><li><strong>功能</strong>: 解决<code>@Autowired</code>在存在多个候选Bean时的冲突问题。通过指定Bean的名称或ID，明确注入的目标。</li><li><strong>使用</strong>: 必须和<code>@Autowired</code>一起使用，以提供明确的注入目标。</li></ul></li><li><p><strong>@Resource</strong>:</p><ul><li><strong>定义</strong>: 是Java EE（也称为Jakarta EE）提供的注解，属于JSR-250规范的一部分，也可以在Spring中使用。</li><li><strong>功能</strong>: 根据名称进行注入。它首先会尝试按名称注入，如果找不到对应的名称，则会按类型进行注入。</li><li><strong>使用</strong>: 更偏向于按名称注入，并且不需要和其他注解（如<code>@Qualifier</code>）一起使用。它的行为与<code>@Autowired</code> + <code>@Qualifier</code>组合有一定相似性，但默认按名称注入，适用于需要根据名称进行注入的场景。</li></ul></li></ul><p><strong>总结</strong>:</p><ul><li><strong>@Autowired</strong>: 按类型自动注入，可以和<code>@Qualifier</code>配合使用。</li><li><strong>@Qualifier</strong>: 用于指定具体的Bean，配合<code>@Autowired</code>使用。</li><li><strong>@Resource</strong>: 按名称进行注入（如果没有找到按名称的Bean，则按类型进行注入）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot3--&gt;springBoot2</title>
      <link href="/2024/08/15/%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84/"/>
      <url>/2024/08/15/%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1-mybatis-plus依赖"><a href="#1-mybatis-plus依赖" class="headerlink" title="1.mybatis-plus依赖"></a>1.mybatis-plus依赖</h2><p>C:\Users\mpk16\Downloads\apartment-system\src\main\java\com\one\apartmentsystem\ApartmentSystemApplication.java:3:37</p><p>java: 无法访问org.mybatis.spring.annotation.MapperScan<br>  错误的类文件: &#x2F;E:&#x2F;Maven&#x2F;apache-maven-3.9.4-bin&#x2F;apache-maven-3.9.4&#x2F;repo&#x2F;org&#x2F;mybatis&#x2F;mybatis-spring&#x2F;3.0.3&#x2F;mybatis-spring-3.0.3.jar!&#x2F;org&#x2F;mybatis&#x2F;spring&#x2F;annotation&#x2F;MapperScan.class<br>    类文件具有错误的版本 61.0, 应为 52.0<br>    请删除该文件或确保该文件位于正确的类路径子目录中。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">将<span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-spring-boot3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">改为</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-tomcat依赖"><a href="#2-tomcat依赖" class="headerlink" title="2.tomcat依赖"></a>2.tomcat依赖</h2><p>java: 无法访问jakarta.servlet.http.HttpSession<br>  错误的类文件: &#x2F;E:&#x2F;Maven&#x2F;apache-maven-3.9.4-bin&#x2F;apache-maven-3.9.4&#x2F;repo&#x2F;org&#x2F;apache&#x2F;tomcat&#x2F;embed&#x2F;tomcat-embed-core&#x2F;10.1.26&#x2F;tomcat-embed-core-10.1.26.jar!&#x2F;jakarta&#x2F;servlet&#x2F;http&#x2F;HttpSession.class<br>    类文件具有错误的版本 55.0, 应为 52.0<br>    请删除该文件或确保该文件位于正确的类路径子目录中。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">删除依赖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>10.1.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-MockMultipartFile"><a href="#3-MockMultipartFile" class="headerlink" title="3.MockMultipartFile"></a>3.MockMultipartFile</h2><p>java: 无法访问org.springframework.mock.web.MockMultipartFile<br>  错误的类文件: &#x2F;E:&#x2F;Maven&#x2F;apache-maven-3.9.4-bin&#x2F;apache-maven-3.9.4&#x2F;repo&#x2F;org&#x2F;springframework&#x2F;spring-test&#x2F;6.1.11&#x2F;spring-test-6.1.11.jar!&#x2F;org&#x2F;springframework&#x2F;mock&#x2F;web&#x2F;MockMultipartFile.class<br>    类文件具有错误的版本 61.0, 应为 52.0<br>    请删除该文件或确保该文件位于正确的类路径子目录中。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-lombok"><a href="#4-lombok" class="headerlink" title="4.lombok"></a>4.lombok</h2><p>Class com.sun.tools.javac.tree.JCTree$JCImport does not have member field ‘com.sun.tools.javac.tree.JCTree qualid’</p><p>打包时出现问题</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/A.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring-boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自动配置原理</title>
      <link href="/2024/08/14/SpringBootB/"/>
      <url>/2024/08/14/SpringBootB/</url>
      
        <content type="html"><![CDATA[<h2 id="1-SpringBootApplication复合注解的作用"><a href="#1-SpringBootApplication复合注解的作用" class="headerlink" title="1.@SpringBootApplication复合注解的作用"></a>1.@SpringBootApplication复合注解的作用</h2><p><img src="/../images/SpringBootApplication.png"></p><h2 id="2-自动配置原理"><a href="#2-自动配置原理" class="headerlink" title="2.自动配置原理"></a>2.自动配置原理</h2><h3 id="2-1-EnableAutoConfiguration"><a href="#2-1-EnableAutoConfiguration" class="headerlink" title="2.1@EnableAutoConfiguration"></a>2.1@EnableAutoConfiguration</h3><p><img src="/../images/EnableAutoConfiguration.png"></p><h3 id="2-2AutoConfigurationImportSelector被加载"><a href="#2-2AutoConfigurationImportSelector被加载" class="headerlink" title="2.2AutoConfigurationImportSelector被加载"></a>2.2AutoConfigurationImportSelector被加载</h3><p><img src="/../images/process.png"></p><h3 id="2-3-调用-List-getCandidateConfigurations-AnnotationMetadata-metadata-AnnotationAttributes-attributes"><a href="#2-3-调用-List-getCandidateConfigurations-AnnotationMetadata-metadata-AnnotationAttributes-attributes" class="headerlink" title="2.3 调用 List getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes)"></a>2.3 调用 List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes)</h3><p>加载META-INF&#x2F;spring.factories中的文件</p><p>以及META-INF&#x2F;spring&#x2F;%s.imports中的文件</p><img src="../images/get.png" style="zoom:100%;" /><h2 id="3-DispatcherServletAutoConfiguration自动配置分析"><a href="#3-DispatcherServletAutoConfiguration自动配置分析" class="headerlink" title="3.DispatcherServletAutoConfiguration自动配置分析"></a>3.DispatcherServletAutoConfiguration自动配置分析</h2><p><img src="/../images/dis.png"></p><h3 id="DispatcherServletAutoConfiguration中含有"><a href="#DispatcherServletAutoConfiguration中含有" class="headerlink" title="DispatcherServletAutoConfiguration中含有"></a>DispatcherServletAutoConfiguration中含有</h3><h3 id="3-1DispatcherServletConfiguration类"><a href="#3-1DispatcherServletConfiguration类" class="headerlink" title="3.1DispatcherServletConfiguration类"></a>3.1DispatcherServletConfiguration类</h3><p><img src="/../images/dis1.png"></p><h4 id="3-1-1-DispatcherServletConfiguration-类注解的详细解释："><a href="#3-1-1-DispatcherServletConfiguration-类注解的详细解释：" class="headerlink" title="3.1.1 DispatcherServletConfiguration 类注解的详细解释："></a><code>3.1.1 DispatcherServletConfiguration</code> 类注解的详细解释：</h4><ol><li><p><strong><code>@Configuration(proxyBeanMethods = false)</code></strong>:</p><ul><li>这个注解表示 <code>DispatcherServletConfiguration</code> 是一个 Spring 配置类。</li><li><code>proxyBeanMethods = false</code> 表示该配置类中的 <code>@Bean</code> 方法不会被代理。意味着 Spring 不会使用 CGLIB 代理来缓存这些方法的结果（通常是为了优化性能）</li></ul></li><li><p><strong><code>@Conditional(DefaultDispatcherServletCondition.class)</code></strong>:</p><ul><li>注解指示 <code>DispatcherServletConfiguration</code> 类的条件性加载。只有当 <code>DefaultDispatcherServletCondition</code> 条件满足时，这个配置类才会生效。<code>DefaultDispatcherServletCondition</code> 是一个自定义条件类，用于决定是否创建该配置类的 bean。这个条件类通常实现了 <code>Condition</code> 接口，并定义了逻辑来判断是否满足生效条件。</li></ul></li><li><p><strong><code>@ConditionalOnClass(ServletRegistration.class)</code></strong>:</p><ul><li>表示 <code>DispatcherServletConfiguration</code> 类仅在类路径中存在 <code>ServletRegistration</code> 类的情况下才会生效。<code>ServletRegistration</code> 是 Servlet API 中的一个类，因此这个条件确保了配置类仅在存在 Servlet API 的环境中被加载。它通常用于确保只有在包含 Servlet 相关类的情况下才会应用此配置。</li></ul></li><li><p><strong><code>@EnableConfigurationProperties(WebMvcProperties.class)</code></strong>:</p><ul><li><p>这个注解启用了 <code>WebMvcProperties</code> 类作为配置属性的支持。这意味着 Spring Boot 会将 <code>WebMvcProperties</code> 类中的属性从配置文件（如 <code>application.properties</code> 或 <code>application.yml</code>）中绑定到 <code>WebMvcProperties</code> 实例中。它允许该配置类访问和使用这些属性</p></li><li><p>前缀为spring.mvc</p><p><img src="/../images/dis3.png"></p></li></ul></li></ol><h3 id="综合条件"><a href="#综合条件" class="headerlink" title="综合条件"></a>综合条件</h3><p><code>DispatcherServletConfiguration</code> 类的生效条件是：</p><ol><li>**<code>DefaultDispatcherServletCondition</code>**：自定义条件类 <code>DefaultDispatcherServletCondition</code> 的条件必须满足。这个条件类通常用于实现特定的逻辑来决定是否加载该配置类。</li><li><strong><code>ServletRegistration</code> 类存在</strong>：类路径中必须包含 <code>ServletRegistration</code> 类。即应用必须使用 Servlet 规范，并且 Servlet API 的相关依赖必须存在。</li><li><strong><code>WebMvcProperties</code> 配置支持</strong>：虽然 <code>@EnableConfigurationProperties(WebMvcProperties.class)</code> 不是生效条件的直接部分，但它指示在配置类加载时，会将配置属性绑定到 <code>WebMvcProperties</code> 实例中。</li></ol><p>综合来说，<code>DispatcherServletConfiguration</code> 仅在满足 <code>DefaultDispatcherServletCondition</code> 条件且类路径中包含 <code>ServletRegistration</code> 类时才会生效。这通常意味着应用是一个基于 Servlet 的 Web 应用，并且 <code>DefaultDispatcherServletCondition</code> 条件是为了进一步精确控制配置类的加载时机。</p><h4 id="3-1-2-Bean"><a href="#3-1-2-Bean" class="headerlink" title="3.1.2 @Bean"></a>3.1.2 @Bean</h4><p><img src="/../images/image-20240814210816547.png" alt="image-20240814210816547"></p><p>注册了disppatcherServlet ，不可被替换</p><p><img src="/../images/image-20240814210854587.png" alt="image-20240814210854587"></p><p>注册了multipartResplver，可以被替换</p><h3 id="3-2DispatcherServletRegistrationConfiguration类"><a href="#3-2DispatcherServletRegistrationConfiguration类" class="headerlink" title="3.2DispatcherServletRegistrationConfiguration类"></a>3.2DispatcherServletRegistrationConfiguration类</h3><p><img src="/../images/dis2.png"></p><h3 id="生效条件分析"><a href="#生效条件分析" class="headerlink" title="生效条件分析"></a>生效条件分析</h3><ol><li><strong><code>@Configuration(proxyBeanMethods = false)</code></strong><ul><li>这是一个标记注解，表示这是一个配置类，用于定义 Spring Bean。</li><li><code>proxyBeanMethods = false</code> 表示不生成 CGLIB 代理，这是默认设置，主要用于提高性能。</li></ul></li><li><strong><code>@Conditional(DispatcherServletRegistrationCondition.class)</code></strong><ul><li>这个注解表示该配置类的生效依赖于 <code>DispatcherServletRegistrationCondition</code> 的条件。</li><li><code>DispatcherServletRegistrationCondition</code> 是一个自定义的条件类，只有当其 <code>matches</code> 方法返回 <code>true</code> 时，这个配置类才会生效。这个条件类的具体实现取决于业务需求，通常用于根据某些条件（如环境、配置等）决定是否应用这个配置。</li></ul></li><li><strong><code>@ConditionalOnClass(ServletRegistration.class)</code></strong><ul><li>这个注解表示当类路径中存在 <code>ServletRegistration</code> 类时，这个配置类才会生效。</li><li><code>ServletRegistration</code> 是 Servlet 的注册相关类，通常是与 Servlet API 相关的类，这意味着当项目中有 Servlet API 相关的依赖时，这个配置类才会被应用。</li></ul></li><li><strong><code>@EnableConfigurationProperties(WebMvcProperties.class)</code></strong><ul><li>这个注解用于启用对 <code>WebMvcProperties</code> 的配置属性支持。</li><li><code>WebMvcProperties</code> 是一个配置属性类，用于从配置文件中读取 Web MVC 相关的配置（如 Servlet 路径、启动加载等）。</li></ul></li><li><strong><code>@Import(DispatcherServletConfiguration.class)</code></strong><ul><li>这个注解用于导入其他配置类。</li><li><code>DispatcherServletConfiguration</code> 可能包含与 <code>DispatcherServlet</code> 相关的其他配置，它将会被导入到当前配置类中。</li></ul></li><li><strong><code>@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)</code></strong><ul><li>这是一个 Spring Bean 定义方法，表示返回一个 <code>DispatcherServletRegistrationBean</code> 实例。</li><li><code>@ConditionalOnBean</code> 注解用于判断只有在 <code>DispatcherServlet</code> Bean 存在时才创建这个 Bean。</li></ul></li><li><strong><code>@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</code></strong><ul><li>这个注解表示只有当 <code>DispatcherServlet</code> Bean 存在并且其名称匹配 <code>DEFAULT_DISPATCHER_SERVLET_BEAN_NAME</code> 时，才会创建 <code>dispatcherServletRegistration</code> 方法中的 Bean。</li><li><code>DispatcherServlet</code> 是 Spring MVC 的核心 Servlet，当它存在时才会进行注册。</li></ul></li></ol><p><strong>这段配置类的生效条件是：</strong></p><ul><li>项目中存在 <code>ServletRegistration</code> 类。</li><li><code>DispatcherServletRegistrationCondition</code> 条件类的 <code>matches</code> 方法返回 <code>true</code>。</li><li><code>WebMvcProperties</code> 类可用（由 <code>@EnableConfigurationProperties</code> 提供支持）。</li><li><code>DispatcherServlet</code> Bean 存在，并且其名称匹配 <code>DEFAULT_DISPATCHER_SERVLET_BEAN_NAME</code>。</li></ul><h2 id="4-HttpEncodingAutoConfiguration"><a href="#4-HttpEncodingAutoConfiguration" class="headerlink" title="4.HttpEncodingAutoConfiguration"></a>4.HttpEncodingAutoConfiguration</h2><p><img src="/../images/encode.png"></p><h3 id="4-1-配置类何时生效？"><a href="#4-1-配置类何时生效？" class="headerlink" title="4.1. 配置类何时生效？"></a>4.1. 配置类何时生效？</h3><p><code>HttpEncodingAutoConfiguration</code> 配置类的生效条件如下：</p><ul><li><p><strong>条件注解</strong>：</p><ul><li><p><code>@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</code></p><p>这个注解确保只有在 Servlet 类型的 web 应用中才会生效。</p></li><li><p>@ConditionalOnClass(CharacterEncodingFilter.class)&#96;</p></li></ul><p>  这个注解检查 <code>CharacterEncodingFilter</code> 类是否存在于类路径中。如果存在，配置类才会生效。</p><ul><li><p><code>@ConditionalOnProperty(prefix = &quot;server.servlet.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)</code>：</p><p>这个注解指定了一个属性前缀和属性值（<code>server.servlet.encoding.enabled</code>）。如果该属性存在并且值为 <code>true</code>，或该属性未设置，则配置类生效。</p></li></ul></li><li><p><strong>作用</strong>： 配置类会在启动时检查这些条件。如果所有条件都满足，那么 Spring Boot 会自动配置 <code>CharacterEncodingFilter</code> 和 <code>LocaleCharsetMappingsCustomizer</code>。</p></li></ul><h3 id="4-2-开启配置绑定了什么？使用什么前缀来操作的？"><a href="#4-2-开启配置绑定了什么？使用什么前缀来操作的？" class="headerlink" title="4.2. 开启配置绑定了什么？使用什么前缀来操作的？"></a>4.2. 开启配置绑定了什么？使用什么前缀来操作的？</h3><ul><li><p><strong>绑定的属性</strong>：</p><ul><li><code>Encoding</code> 对象：配置类通过 <code>ServerProperties</code> 的 <code>getServlet().getEncoding()</code> 方法获取 <code>Encoding</code> 配置。这个对象封装了字符编码的配置，例如字符集和强制编码设置。</li></ul></li><li><p><strong>前缀</strong>：</p><ul><li><p>配置类使用的前缀是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.servlet.encoding</span><br></pre></td></tr></table></figure><p>。例如：</p><ul><li><code>server.servlet.encoding.charset</code>：定义字符集。</li><li><code>server.servlet.encoding.force-request</code>：是否强制请求编码。</li><li><code>server.servlet.encoding.force-response</code>：是否强制响应编码。</li></ul></li></ul></li></ul><h3 id="4-3-Bean-注入了哪些组件？能否自己替换？"><a href="#4-3-Bean-注入了哪些组件？能否自己替换？" class="headerlink" title="4.3. @Bean 注入了哪些组件？能否自己替换？"></a>4.3. <code>@Bean</code> 注入了哪些组件？能否自己替换？</h3><ul><li><p><strong>注入的组件</strong>：</p><ul><li><pre><code>CharacterEncodingFilter：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 通过 `@Bean` 注解，配置类创建并返回一个 `CharacterEncodingFilter` 实例，该实例是 `OrderedCharacterEncodingFilter` 的子类。</span><br><span class="line">  - 该过滤器用于设置 HTTP 请求和响应的字符编码。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  LocaleCharsetMappingsCustomizer：</span><br></pre></td></tr></table></figure>- 另一个 `@Bean` 注入的组件。它实现了 `WebServerFactoryCustomizer` 接口，允许自定义 web 服务器的 locale 和 charset 映射。</code></pre></li></ul></li><li><p><strong>是否可以替换</strong>：</p><ul><li>**<code>CharacterEncodingFilter</code>**：<ul><li>可以通过定义一个具有相同 bean 名称或类型的自定义 <code>CharacterEncodingFilter</code> 来替换。</li><li>由于 <code>@ConditionalOnMissingBean</code> 注解，只有在没有其他 <code>CharacterEncodingFilter</code> bean 时才会创建默认的 <code>OrderedCharacterEncodingFilter</code>。</li></ul></li><li>**<code>LocaleCharsetMappingsCustomizer</code>**：<ul><li>可以通过定义一个自定义的 <code>WebServerFactoryCustomizer</code> bean 来替换。</li><li>自定义实现可以调整 locale 和 charset 映射逻辑，允许开发者根据需求进行配置。</li></ul></li></ul></li></ul><h2 id="5-静态资源的默认规则"><a href="#5-静态资源的默认规则" class="headerlink" title="5.静态资源的默认规则"></a>5.静态资源的默认规则</h2><p><img src="/../images/web33.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring-boot </tag>
            
            <tag> 底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-boot依赖管理与底层注解</title>
      <link href="/2024/08/13/springBootA/"/>
      <url>/2024/08/13/springBootA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-springBoot依赖管理特性"><a href="#1-springBoot依赖管理特性" class="headerlink" title="1.springBoot依赖管理特性"></a>1.springBoot依赖管理特性</h2><p><img src="/../images/B.png"></p><h2 id="2-SpringBoot中的底层注解和作用"><a href="#2-SpringBoot中的底层注解和作用" class="headerlink" title="2.SpringBoot中的底层注解和作用"></a>2.SpringBoot中的底层注解和作用</h2><ul><li><p>**<code>@Configuration</code>**：标志类为Spring的配置类，定义了一个或多个<code>@Bean</code>方法，Spring容器会通过这些方法创建和管理Bean实例。</p></li><li><p>**<code>@Import</code>**：用于将其他配置类或组件导入当前配置类，从而使得被导入的配置类中的Bean也可以在当前Spring上下文中使用。</p></li><li><p>**<code>@Conditional</code>**：用于在满足特定条件时才会激活配置或Bean的创建。通过与<code>Condition</code>接口配合，可以根据不同的环境或条件来决定是否加载某些Bean。</p></li><li><p>**<code>@ImportResource</code>**：允许将传统的XML配置文件导入到Spring Boot的应用上下文中，从而可以混合使用Java配置和XML配置。</p></li><li><p>**<code>@ConfigurationProperties</code>**：将配置文件中的属性（如<code>application.properties</code>或<code>application.yml</code>）映射到Java对象中。通过在类上使用该注解，可以将配置属性绑定到Bean的字段上，使得配置更加结构化和类型安全。</p></li><li><p>注解的简要示例：</p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a><strong><code>@Configuration</code></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>@Configuration</code>标记了<code>AppConfig</code>类为配置类，<code>myService</code>方法创建了一个<code>MyService</code> Bean。</li></ul><h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a><strong><code>@Import</code></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(OtherConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>@Import</code>将<code>OtherConfig</code>中的配置导入到<code>MainConfig</code>中，使得<code>OtherConfig</code>中的Bean也在<code>MainConfig</code>的上下文中可用。</li></ul><h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a><strong><code>@Conditional</code></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional(OnDevelopmentCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DevConfig</span> &#123;</span><br><span class="line">    <span class="comment">// Bean definitions specific to development environment</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>解释</strong>：<code>@Conditional</code>与<code>OnDevelopmentCondition</code>条件配合，<code>DevConfig</code>中的配置仅在满足<code>OnDevelopmentCondition</code>条件时才会被激活。</p></li><li><p><code>@Conditional</code> 注解的继承类在Spring中用于定义条件化的Bean注册逻辑。</p></li><li><p>常见的继承类及其作用包括：</p><ol><li><p><strong><code>@ConditionalOnClass</code></strong>: 仅当指定的类在类路径中存在时才注册Bean。</p><ul><li><p><strong>作用</strong>: 用于在某个类存在时才加载相关的Bean。</p></li><li><p>示例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(DataSource.class)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>@ConditionalOnMissingBean</code></strong>: 仅当容器中缺少指定的Bean时才注册Bean。</p><ul><li><p><strong>作用</strong>: 用于在缺少某个Bean时提供默认实现。</p></li><li><p>示例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingBean(MyBean.class)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>@ConditionalOnProperty</code></strong>: 仅当某个属性的值满足指定条件时才注册Bean。</p><ul><li><p><strong>作用</strong>: 用于根据配置属性的值来启用或禁用Bean。</p></li><li><p>示例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;feature.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeatureConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FeatureService <span class="title function_">featureService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FeatureService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>@ConditionalOnExpression</code></strong>: 仅当指定的SpEL表达式为true时才注册Bean。</p><ul><li><p><strong>作用</strong>: 用于基于SpEL表达式的动态条件来决定Bean的创建。</p></li><li><p>示例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnExpression(&quot;#&#123;systemProperties[&#x27;os.name&#x27;].contains(&#x27;Windows&#x27;)&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowsConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WindowsService <span class="title function_">windowsService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>@ConditionalOnBean</code></strong>: 仅当容器中存在指定的Bean时才注册Bean。</p><ul><li><p><strong>作用</strong>: 用于在某些Bean存在时才创建其他Bean。</p></li><li><p>示例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnBean(DataSource.class)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceDependentConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataService <span class="title function_">dataService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>这些条件化注解使得Spring应用程序可以根据不同的环境、配置或依赖条件动态地注册或忽略某些Bean，增强了应用的灵活性和可配置性。</p></li></ul><h3 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a><strong><code>@ImportResource</code></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>@ImportResource</code>将<code>beans.xml</code>中的XML配置导入到Spring应用上下文中，可以与Java配置混合使用。</li></ul><h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a><strong><code>@ConfigurationProperties</code></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;app&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> timeout;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>@ConfigurationProperties</code>将<code>application.properties</code>或<code>application.yml</code>中以<code>app</code>为前缀的配置属性自动绑定到<code>AppProperties</code>类的字段上。</li></ul><h3 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a><strong>配置文件示例</strong></h3><p><code>application.properties</code>:</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="attr">app.timeout</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：上述配置文件中的<code>app.name</code>和<code>app.timeout</code>将被自动绑定到<code>AppProperties</code>类中的对应字段上。</li></ul><p>这些示例展示了如何使用不同的Spring注解来定义配置类、导入配置、控制Bean的加载、结合XML配置和自动绑定配置属性。</p></li></ul><h2 id="3-SpringBoot的优点"><a href="#3-SpringBoot的优点" class="headerlink" title="3.SpringBoot的优点"></a>3.SpringBoot的优点</h2><ol><li><p><strong>快速启动</strong>:</p><ul><li><strong>优点</strong>: Spring Boot通过提供起步依赖（starters）和自动配置，显著减少了项目初始化的复杂度。</li><li><strong>举例</strong>: 使用<code>spring-boot-starter-web</code>可以快速构建一个Web应用，只需添加这个依赖，Spring Boot会自动配置Spring MVC、嵌入式Tomcat等。</li></ul></li><li><p><strong>自动配置</strong>:</p><ul><li><strong>优点</strong>: Spring Boot会自动根据应用的依赖和环境配置Spring Beans，简化配置工作。</li><li><strong>举例</strong>: 如果你在<code>pom.xml</code>中添加了<code>spring-boot-starter-data-jpa</code>，Spring Boot会自动配置数据源、EntityManagerFactory等JPA相关组件。</li></ul></li><li><p><strong>嵌入式服务器</strong>:</p><ul><li><strong>优点</strong>: 支持将应用打包成一个独立的JAR文件，包含内嵌的Tomcat、Jetty等Web服务器，无需外部服务器。</li><li><strong>举例</strong>: 通过<code>spring-boot-starter-tomcat</code>，你可以将整个应用打包成一个JAR，并用<code>java -jar</code>命令直接启动它。</li></ul></li><li><p><strong>生产就绪</strong>:</p><ul><li><strong>优点</strong>: 内置Actuator模块提供了健康检查、应用指标、日志等功能，有助于生产环境的监控和管理。</li><li><strong>举例</strong>: 使用<code>spring-boot-starter-actuator</code>，可以通过<code>/actuator/health</code>端点监控应用的健康状态。</li></ul></li><li><p><strong>约定优于配置</strong>:</p><ul><li><strong>优点</strong>: 提供了合理的默认配置，减少了繁琐的自定义设置。</li><li><strong>举例</strong>: 默认情况下，Spring Boot将应用配置文件放置于<code>src/main/resources/application.properties</code>，并自动加载它们。</li></ul></li><li><p><strong>模块化</strong>:</p><ul><li><strong>优点</strong>: 通过各种启动器（starters）简化了依赖管理和常见功能的集成。</li><li><strong>举例</strong>: 使用<code>spring-boot-starter-security</code>可以轻松集成Spring Security，提供默认的安全配置。</li></ul></li><li><p><strong>简化的配置</strong>:</p><ul><li><p><strong>优点</strong>: 配置可以通过<code>application.properties</code>或<code>application.yml</code>文件集中管理，支持外部化配置。</p></li><li><p>举例</p><p>: 可以在</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">application.yml</span><br></pre></td></tr></table></figure><p>中配置数据库连接：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yamlspring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3306/mydb</span><br><span class="line">    username: user</span><br><span class="line">    password: pass</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>社区支持</strong>:</p><ul><li><strong>优点</strong>: 作为Spring生态的一部分，Spring Boot拥有广泛的社区支持和丰富的文档资源。</li><li><strong>举例</strong>: 你可以访问Spring Boot的官方文档、社区论坛和GitHub上的示例代码来解决开发中的问题。</li></ul></li></ol><p>这些优点使得Spring Boot在开发现代Java应用时特别高效和便捷。</p><h2 id="4-个人git网址"><a href="#4-个人git网址" class="headerlink" title="4.个人git网址"></a>4.个人git网址</h2><p> <a href="https://gitee.com/ma-pengkun/spring-boot-learn/tree/master/springBootA/src/main">springBootA&#x2F;src&#x2F;main · 马朋坤&#x2F;SpringBootLearn - 码云 - 开源中国 (gitee.com)</a> </p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring-boot </tag>
            
            <tag> 底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式、方法引用、Stream流</title>
      <link href="/2024/06/05/3.JavaSE%E9%AB%98%E7%BA%A7%20Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;Stream%E6%B5%81&amp;%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
      <url>/2024/06/05/3.JavaSE%E9%AB%98%E7%BA%A7%20Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;Stream%E6%B5%81&amp;%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Lambda表达式、方法引用、Stream流"><a href="#Lambda表达式、方法引用、Stream流" class="headerlink" title="Lambda表达式、方法引用、Stream流"></a>Lambda表达式、方法引用、Stream流</h1><h1 id="第一章-JDK8新特性"><a href="#第一章-JDK8新特性" class="headerlink" title="第一章 JDK8新特性"></a>第一章 JDK8新特性</h1><blockquote><p>JDK新特性：</p><p><strong>Lambda 表达式</strong></p><p><strong>默认方法</strong>【已学习过】</p><p><strong>Stream API</strong> </p><p><strong>方法引用</strong></p><p><strong>Base64</strong></p></blockquote><h2 id="1-1-Lambda表达式"><a href="#1-1-Lambda表达式" class="headerlink" title="1.1 Lambda表达式"></a>1.1 Lambda表达式</h2><h3 id="1-1-1-函数式编程思想概述"><a href="#1-1-1-函数式编程思想概述" class="headerlink" title="1.1.1 函数式编程思想概述"></a>1.1.1 函数式编程思想概述</h3><p><img src="/../images/03-Overview.png"></p><p>​在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p><p><strong>做什么，而不是怎么做</strong></p><p>​我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>compare</code>方法体内的代码传递给<code>TreeSet</code>集合知晓。</p><p>​<strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p><h3 id="1-1-2-Lambda的优化"><a href="#1-1-2-Lambda的优化" class="headerlink" title="1.1.2 Lambda的优化"></a>1.1.2 Lambda的优化</h3><p>​当需要给Swing的组件添加事件时，例如给JButton按钮绑定鼠标点击事件，需要通过<code>ActionListener</code>接口来定义触发事件后执行的操作。</p><p><strong>传统写法,代码如下：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;按钮&quot;</span>);</span><br><span class="line">button.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;按钮被点击了！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>ActionListener</code>接口的匿名内部类对象来指定按钮发生鼠标点击事件后执行的操作。</p><p><strong>代码分析:</strong></p><p>对于<code>ActionListener</code>的匿名内部类用法，可以分析出几点内容：</p><ul><li>按钮绑定监听器，需要<code>ActionListener</code>接口作为参数，其中的抽象<code>actionPerformed</code>方法是用来指定按钮被鼠标点击后执行的操作；</li><li>为了指定<code>actionPerformed</code>的方法体，<strong>不得不</strong>需要<code>ActionListener</code>接口的实现类；</li><li>为了省去定义一个<code>ActionListener</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>actionPerformed</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li></ul><p><img src="/../images/02-Lambda(2).png"></p><p><strong>Lambda表达式写法,代码如下：</strong></p><p>借助Java 8的全新语法，上述<code>ActionListener</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;按钮&quot;</span>);</span><br><span class="line"></span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;按钮被点击了！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Lambda表达式简化后</span></span><br><span class="line">        button.addActionListener((ActionEvent e) -&gt; &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;按钮被点击了！&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：按钮触发了鼠标点击事件后执行的操作，而执行的操作以一种更加简洁的形式被指定。</p><p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p><h3 id="1-1-3-Lambda的格式"><a href="#1-1-3-Lambda的格式" class="headerlink" title="1.1.3 Lambda的格式"></a>1.1.3 Lambda的格式</h3><h4 id="标准格式"><a href="#标准格式" class="headerlink" title="标准格式"></a>标准格式</h4><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p><ul><li>一些参数</li><li>一个箭头</li><li>一段代码</li></ul><p>Lambda表达式的<strong>标准格式</strong>为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure><p><strong>格式说明：</strong></p><ul><li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li><li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li><li>大括号内的语法与传统方法体要求基本一致。</li></ul><p><strong>匿名内部类与lambda对比:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">button.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;按钮被点击了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda</span></span><br><span class="line">button.addActionListener((ActionEvent e) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;按钮被点击了！&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>仔细分析该代码中，<code>ActionListener</code>接口只有一个<code>actionPerformed</code>方法的定义：</p><ul><li><code>public abstract void actionPerformed(ActionEvent e);</code></li></ul><p>即制定了一种做事情的方案（其实就是一个方法）</p><p><strong>总结：lambda表达式简化匿名内部类，首先要求是接口，其次是该接口只有一个抽象方法。</strong></p><h4 id="无参数"><a href="#无参数" class="headerlink" title="无参数"></a>无参数</h4><ul><li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li><li><strong>无返回值</strong>：该方案不产生任何结果。</li><li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li></ul><p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程中的写法</span></span><br><span class="line">() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li><li>中间的一个箭头代表将前面的参数传递给后面的代码；</li><li>后面的输出语句即业务逻辑代码。</li><li></li></ul><h4 id="有参数和返回值"><a href="#有参数和返回值" class="headerlink" title="有参数和返回值"></a>有参数和返回值</h4><p>下面举例演示<code>java.util.Comparator&lt;T&gt;</code>接口的使用场景代码，其中的抽象方法定义为：</p><ul><li><code>public abstract int compare(T o1, T o2);</code></li></ul><p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略构造器、toString方法与Getter Setter </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>传统写法</strong></p><p>如果使用传统的代码对<code>Person[]</code>数组进行排序，写法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// 本来年龄乱序的对象数组</span></span><br><span class="line">        Person[] array = &#123; </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">19</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">18</span>),       </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">20</span>) </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 匿名内部类</span></span><br><span class="line">        Comparator&lt;Person&gt; comp = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(array, comp); <span class="comment">// 第二个参数为排序规则，即Comparator接口实例</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中<code>Comparator</code>接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p><p><strong>代码分析</strong></p><p>下面我们来搞清楚上述代码真正要做什么事情。</p><ul><li>为了排序，<code>Arrays.sort</code>方法需要排序规则，即<code>Comparator</code>接口的实例，抽象方法<code>compare</code>是关键；</li><li>为了指定<code>compare</code>的方法体，<strong>不得不</strong>需要<code>Comparator</code>接口的实现类；</li><li>为了省去定义一个<code>ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>实际上，<strong>只有参数和方法体才是关键</strong>。</li></ul><p><strong>Lambda写法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">19</span>),</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">18</span>),</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">20</span>) </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        Arrays.sort(array, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Lambda</span></span><br><span class="line">        Arrays.sort(array, (Person a, Person b) -&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> a.getAge() - b.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="省略格式"><a href="#省略格式" class="headerlink" title="省略格式"></a>省略格式</h4><p><strong>省略规则</strong></p><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内<strong>有且仅有一个参数</strong>，则小括号可以省略；</li><li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、语句分号，必须省略return关键字。</li></ol><p><strong>可推导即可省略</strong></p><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。</p><p>例如上例还可以使用Lambda的省略写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Runnable接口简化:</span></span><br><span class="line"><span class="number">1.</span> () -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Comparator接口简化:</span></span><br><span class="line"><span class="number">2.</span> Arrays.sort(array, (a, b) -&gt; a.getAge() - b.getAge());</span><br><span class="line"></span><br><span class="line"><span class="comment">//ActionListener接口简化：</span></span><br><span class="line"><span class="number">3.</span>button.addActionListener(e -&gt; System.out.println(<span class="string">&quot;按钮被点击了！&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="1-1-4-Lambda的前提条件"><a href="#1-1-4-Lambda的前提条件" class="headerlink" title="1.1.4 Lambda的前提条件"></a>1.1.4 Lambda的前提条件</h3><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p><ol><li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li><li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li></ol><blockquote><p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p></blockquote><h2 id="1-2-函数式接口"><a href="#1-2-函数式接口" class="headerlink" title="1.2 函数式接口"></a>1.2 函数式接口</h2><h3 id="1-2-1-函数式接口概念"><a href="#1-2-1-函数式接口概念" class="headerlink" title="1.2.1 函数式接口概念"></a>1.2.1 函数式接口概念</h3><p>​函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。注解<code>@FunctionalInterface</code>可以检测接口是否是一个函数式接口。(在合作开发中，避免同事修改此接口造成错误)</p><h3 id="1-2-2-函数定义及使用"><a href="#1-2-2-函数定义及使用" class="headerlink" title="1.2.2 函数定义及使用"></a>1.2.2 函数定义及使用</h3><p><strong>定义一个函数式接口:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//问候</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">sayMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>定义此函数式接口的实现类：</strong> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;say hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>函数式接口一般作为方法的参数和返回值类型：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个方法，参数使用函数式接口GreetingService</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(GreetingService greetingService)</span>&#123;</span><br><span class="line">        greetingService.sayMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用show方法，方法的参数是一个接口，所以可以传递接口的实现类</span></span><br><span class="line">        show(<span class="keyword">new</span> <span class="title class_">GreetingServiceImpl</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用show方法，方法的参数是一个接口，所以可以传递接口的匿名内部类</span></span><br><span class="line">        show(<span class="keyword">new</span> <span class="title class_">GreetingService</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;使用匿名内部类重写接口中的抽象方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lambda表达式的写法：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个方法，参数使用函数式接口GreetingService</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(GreetingService greetingService)</span>&#123;</span><br><span class="line">        greetingService.sayMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用show方法，使用lambda表达式</span></span><br><span class="line">        show(()-&gt;System.out.println(<span class="string">&quot;使用lambda重写接口中的抽象方法&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-3-使用lambda表达式的好处"><a href="#1-2-3-使用lambda表达式的好处" class="headerlink" title="1.2.3 使用lambda表达式的好处"></a>1.2.3 使用lambda表达式的好处</h3><p>优势：1.简化代码，更为简洁    2.延迟加载</p><p>​有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以作为解决方案，提升性能。 </p><p>例如：<strong>性能浪费的日志案例</strong><br>PS：日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。</p><p> 一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msgA</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msgB</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msgC</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>;</span><br><span class="line">    showLog(<span class="number">1</span>, msgA + msgB + msgC);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showLog</span><span class="params">(<span class="type">int</span> level, String msg)</span> &#123;</span><br><span class="line">    <span class="comment">//当日志级别为1时，打印日志</span></span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">      System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码存在问题：无论级别是否满足要求，作为<code>showLog</code> 方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。</p><p><strong>使用lambda必然先定义一个函数式接口：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MessageBuilder</span>&#123;</span><br><span class="line">    String <span class="title function_">buildMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 对showLog方法进行改造 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] ags)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msgA</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msgB</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msgC</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//lambda实现显示日志</span></span><br><span class="line">        showLogLambda(<span class="number">1</span>,()-&gt;msgA+msgB+msgC);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//证明lambda表达式的延迟执行</span></span><br><span class="line">        showLogLambda(<span class="number">1</span>,()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Lambda执行！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> msgA+msgB+msgC;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showLogLambda</span><span class="params">(<span class="type">int</span> level,MessageBuilder builder)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(builder.buildMessage());</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。 </p><h3 id="1-2-4-常用的函数式接口"><a href="#1-2-4-常用的函数式接口" class="headerlink" title="1.2.4 常用的函数式接口"></a>1.2.4 常用的函数式接口</h3><p>​要使用lambda表达式，我们就要创建一个函数式接口，那每次用lambda表达式的时候岂不是很麻烦，这时候，java给我们内置了<code>四大核心函数式接口</code>。</p><p><strong>四大核心函数式接口</strong></p><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>用途</th></tr></thead><tbody><tr><td>Supplier&lt; T&gt;接口,供给型接口</td><td>无</td><td>T</td><td>返回类型为T的对象，T get()</td></tr><tr><td>Consumer&lt; T&gt;接口，消费型接口</td><td>T</td><td>void</td><td>对类型为T的对象应用操作，void accept(T t)</td></tr><tr><td>Function&lt;T,R&gt; 函数型接口</td><td>T</td><td>R</td><td>根据类型T的参数获取类型R的结果,R apply(T t)</td></tr><tr><td>Predicate&lt; T&gt;接口,断定型接口</td><td>T</td><td>boolean</td><td>用于条件判断的场景,boolean test(T t)</td></tr></tbody></table><h4 id="Supplier-T-接口"><a href="#Supplier-T-接口" class="headerlink" title="Supplier&lt; T&gt;接口"></a>Supplier&lt; T&gt;接口</h4><p>​<code>java.util.function.Supplier</code> 接口仅包含一个无参的方法： T get() 。用来获取一个泛型参数指定类型的对象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象数据。</p><h5 id="抽象方法get"><a href="#抽象方法get" class="headerlink" title="抽象方法get"></a>抽象方法get</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSupplier</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(Supplier&lt;String&gt; function)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function.get();  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String msgA= <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        String msgB=<span class="string">&quot;World&quot;</span>;</span><br><span class="line">        System.out.println(getString(()-&gt;msgA+msgB));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Consumer-T-接口"><a href="#Consumer-T-接口" class="headerlink" title="Consumer&lt; T&gt;接口"></a>Consumer&lt; T&gt;接口</h4><p>​<code>java.util.function.Consumer</code> 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定。<br>Consumer提供了accept(T t)的抽象方法，和andThen的默认方法,查看源码如下：</p><p> <img src="/../images/webp.png" alt="img"> </p><h5 id="抽象方法accept"><a href="#抽象方法accept" class="headerlink" title="抽象方法accept"></a>抽象方法accept</h5><p>Consumer 接口中包含抽象方法void accept(T t) ，意为消费一个指定泛型的数据。</p><p>基本使用如： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        consumerString(s-&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumerString</span><span class="params">(Consumer&lt;String&gt; consumer)</span>&#123;</span><br><span class="line">        consumer.accept(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认方法andThen"><a href="#默认方法andThen" class="headerlink" title="默认方法andThen"></a>默认方法andThen</h5><p>如果一个方法的参数和返回值全都是Consumer 类型，那么就可以实现效果：消费数据的时候，首先做一个操作，然后再做一个操作，实现组合。而这个方法就是Consumer 接口中的default方法andThen 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConsumerAndThen</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        cosumerAndthen(s-&gt; System.out.println(s.toLowerCase()),s-&gt; System.out.println(s.toUpperCase()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cosumerAndthen</span><span class="params">(Consumer&lt;String&gt; one,Consumer&lt;String&gt; two)</span>&#123;</span><br><span class="line">        one.andThen(two).accept(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Function接口"><a href="#Function接口" class="headerlink" title="Function&lt;T,R&gt;接口"></a>Function&lt;T,R&gt;接口</h4><p> <code>java.util.function.Function</code>接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。 </p><h5 id="抽象方法apply"><a href="#抽象方法apply" class="headerlink" title="抽象方法apply"></a>抽象方法apply</h5><p>Function&lt;T,R&gt;接口中最主要的抽象方法为： R apply(T t) ，根据类型T的参数获取类型R的结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将String类型转换为Integer类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFunction</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(s-&gt;Integer.parseInt(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer <span class="title function_">method</span><span class="params">(Function&lt;String,Integer&gt; function)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span>  function.apply(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认方法andThen-1"><a href="#默认方法andThen-1" class="headerlink" title="默认方法andThen"></a>默认方法andThen</h5><p>Function 接口中有一个默认的andThen 方法，用来进行组合操作。该方法同样用于“先做什么，再做什么”的场景，和Consumer 中的andThen 差不多：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个操作是将字符串解析成为int数字，第二个操作是乘以10。两个操作通过andThen按照前后顺序组合到了一起。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFunctionAndthen</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(s-&gt;Integer.parseInt(s) , i-&gt;i*<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Function&lt;String,Integer&gt; one,Function&lt;Integer,Integer&gt; two)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> one.andThen(two).apply(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Predicate-T-接口"><a href="#Predicate-T-接口" class="headerlink" title="Predicate&lt; T&gt;接口"></a>Predicate&lt; T&gt;接口</h4><p>有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。这时可以使用<br><code>java.util.function.Predicate</code>接口。 </p><h5 id="抽象方法test"><a href="#抽象方法test" class="headerlink" title="抽象方法test"></a>抽象方法test</h5><p>Predicate 接口中包含一个抽象方法： boolean test(T t) 。</p><p>用于条件判断的场景： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPredicate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(s -&gt; s.length()&gt;<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Predicate&lt;String&gt; predicate)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> predicate.test(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串很长？&quot;</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认方法and-与"><a href="#默认方法and-与" class="headerlink" title="默认方法and 与"></a>默认方法and 与</h5><p>既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个Predicate 条件使用“与”逻辑连接起来实现“并且”的效果时，可以使用default方法and.<br>判断一个字符串既要包含大写“H”，又要包含大写“W”，则：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPredicateAnd</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(s-&gt;s.contains(<span class="string">&quot;H&quot;</span>),s-&gt;s.contains(<span class="string">&quot;W&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Predicate&lt;String&gt; one,Predicate&lt;String&gt; two)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> one.and(two).test(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串是否符合要求？&quot;</span>+b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认方法or-或"><a href="#默认方法or-或" class="headerlink" title="默认方法or 或"></a>默认方法or 或</h5><p>如果希望实现逻辑“字符串包含大写H或者包含大写W”，那么代码只需要将“and”修改为“or”名称即可，其他都不变：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPredicateOr</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(s-&gt;s.contains(<span class="string">&quot;H&quot;</span>),s-&gt;s.contains(<span class="string">&quot;W&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Predicate&lt;String&gt; one,Predicate&lt;String&gt; two)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> one.or(two).test(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串是否符合要求？&quot;</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认方法negate-非"><a href="#默认方法negate-非" class="headerlink" title="默认方法negate 非"></a>默认方法negate 非</h5><p>“与”、“或”已经了解了，剩下的“非”（取反）也会简单.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPredicate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(s-&gt;s.length()&gt;<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Predicate&lt;String&gt; predicate)</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> predicate.negate().test(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串很长？&quot;</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-方法引用"><a href="#1-3-方法引用" class="headerlink" title="1.3 方法引用"></a>1.3 方法引用</h2><h3 id="1-3-1-方法引用概述"><a href="#1-3-1-方法引用概述" class="headerlink" title="1.3.1 方法引用概述"></a>1.3.1 方法引用概述</h3><p>​方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象。方法引用和Lambda表达式配合使用，使得java类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。</p><h3 id="1-3-2-静态方法的引用"><a href="#1-3-2-静态方法的引用" class="headerlink" title="1.3.2 静态方法的引用"></a>1.3.2 静态方法的引用</h3><p>​引用格式：</p><p>​类名::静态方法</p><p>​简化步骤：</p><p>​定义一个静态方法，把需要简化的代码放到一个静态方法中。</p><p>​注意事项：</p><p>​被引用的方法的参数列表，要和函数式接口中的抽象方法的参数列表一致。</p><p>​如果函数式接口中的抽象方法有返回值，则被引用的方法必须也有相同的返回值。</p><p>​如果函数式接口中的抽象方法没有返回值，则被引用的方法可以有返回值，也可以没有返回值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lambda</span></span><br><span class="line">Arrays.sort(array, (Person a, Person b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a.getAge() - b.getAge();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//Comparator接口简化:</span></span><br><span class="line">Arrays.sort(array, (a, b) -&gt; a.getAge() - b.getAge());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法的引用简化：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareByAge</span><span class="params">(Person a, Person b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.getAge() - b.getAge();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简化1：</span></span><br><span class="line">Arrays.sort(array, (a, b) -&gt; Person.compareByAge(a,b));</span><br><span class="line"><span class="comment">//简化2：</span></span><br><span class="line">Arrays.sort(array, Person::compareByAge);</span><br></pre></td></tr></table></figure><h3 id="1-3-3-实例方法的引用"><a href="#1-3-3-实例方法的引用" class="headerlink" title="1.3.3 实例方法的引用"></a>1.3.3 实例方法的引用</h3><p>​引用格式：</p><p>​对象::实例方法</p><p>​简化步骤：</p><p>​定义一个实例方法，把需要的代码放到实例方法中</p><p>​注意事项：</p><p>​被引用的方法的参数列表，要和函数式接口中的抽象方法的参数列表一致。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化1：</span></span><br><span class="line">list.forEach(s -&gt; System.out.println(s));</span><br><span class="line"><span class="comment">//简化2： 对象是System.out=new PrintStream();  实例方法是println()</span></span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="1-3-4-特定类型方法的引用"><a href="#1-3-4-特定类型方法的引用" class="headerlink" title="1.3.4 特定类型方法的引用"></a>1.3.4 特定类型方法的引用</h3><p>​引用格式：</p><p>​特定类型::方法</p><p>​特点类型：</p><p>​String，任何类型</p><p>​注意事项：</p><p>​如果函数式接口中的抽象方法的参数列表中，第一个参数作为了后面的方法的调用者，并且其余参数作为后面方法的形参，那么就可以用特定类型方法引用了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(strs, (String s1 , String s2) -&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> s1.compareToIgnoreCase(s2); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化1：</span></span><br><span class="line">Arrays.sort(strs, (s1,s2) -&gt; s1.compareToIgnoreCase(s2));</span><br><span class="line"><span class="comment">//简化2：</span></span><br><span class="line">Arrays.sort(strs, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure><h3 id="1-3-5-构造器引用"><a href="#1-3-5-构造器引用" class="headerlink" title="1.3.5 构造器引用"></a>1.3.5 构造器引用</h3><p>​引用格式：</p><p>​类名::new</p><p>​注意事项：</p><p>​函数式接口的抽象方法的形参列表和构造器的形参列表一致，抽象方法的返回值类型即为构造器所属的类的类型。</p><p>​类似于  s -&gt; new Student(s)   &#x3D;&gt; Student::new</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参构造</span></span><br><span class="line">Supplier&lt;Employee&gt; sup1 = () -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;----------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">Supplier&lt;Employee&gt; sup2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">System.out.println(sup2.get());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Function&lt;Integer,Employee&gt; func1 = id -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(id);</span><br><span class="line">System.out.println(func1.apply(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;----------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">Function&lt;Integer,Employee&gt; func2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">System.out.println(func2.apply(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>数组引用：把数组看成是一个特殊的类，则写法和构造器引用一致</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer,String[]&gt; func1 = (length)-&gt;<span class="keyword">new</span> <span class="title class_">String</span>[length];</span><br><span class="line">String[] arr1 = func1.apply(<span class="number">6</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;----------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">Function&lt;Integer,String[]&gt; func2 = String[]::<span class="keyword">new</span>;</span><br><span class="line">String[] arr2=func2.apply(<span class="number">1</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr2));</span><br></pre></td></tr></table></figure><h1 id="第二章-Stream"><a href="#第二章-Stream" class="headerlink" title="第二章 Stream"></a>第二章 Stream</h1><p>在Java 8中，得益于Lambda所带来的函数式编程，引入了一个<strong>全新的Stream概念</strong>，用于解决已有集合类库既有的弊端。</p><h2 id="2-1-引言"><a href="#2-1-引言" class="headerlink" title="2.1 引言"></a>2.1 引言</h2><p><strong>传统集合的多步遍历代码</strong></p><p>几乎所有的集合（如<code>Collection</code>接口或<code>Map</code>接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元素进行操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01ForEach</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : list) &#123;</span><br><span class="line">          System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一段非常简单的集合遍历操作：对集合中的每一个字符串都进行打印输出操作。</p><p><strong>循环遍历的弊端</strong></p><p>Java 8的Lambda让我们可以更加专注于<strong>做什么</strong>（What），而不是<strong>怎么做</strong>（How），这点此前已经结合内部类进行了对比说明。现在，我们仔细体会一下上例代码，可以发现：</p><ul><li>for循环的语法就是“<strong>怎么做</strong>”</li><li>for循环的循环体才是“<strong>做什么</strong>”</li></ul><p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，<strong>而并不是从第一个到最后一个顺次处理的循环</strong>。前者是目的，后者是方式。</p><p>试想一下，如果希望对集合中的元素进行筛选过滤：</p><ol><li>将集合A根据条件一过滤为<strong>子集B</strong>；</li><li>然后再根据条件二过滤为<strong>子集C</strong>。</li></ol><p>那怎么办？在Java 8之前的做法可能为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02NormalFilter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; zhangList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;张&quot;</span>)) &#123;</span><br><span class="line">              zhangList.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; shortList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : zhangList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">3</span>) &#123;</span><br><span class="line">              shortList.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : shortList) &#123;</span><br><span class="line">          System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中含有三个循环，每一个作用不同：</p><ol><li>首先筛选所有姓张的人；</li><li>然后筛选名字有三个字的人；</li><li>最后进行对结果进行打印输出。</li></ol><p>每当我们需要对集合中的元素进行操作的时候，总是需要进行循环、循环、再循环。这是理所当然的么？<strong>不是。</strong>循环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使用另一个循环从头开始。</p><p>那，Lambda的衍生物Stream能给我们带来怎样更加优雅的写法呢？</p><p><strong>Stream的更优写法</strong></p><p>下面来看一下借助Java 8的Stream API，什么才叫优雅：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03StreamFilter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵敏&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list.stream()</span><br><span class="line">          .filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">            .filter(s -&gt; s.length() == <span class="number">3</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：<strong>获取流、过滤姓张、过滤长度为3、逐一打印</strong>。代码中并没有体现使用线性循环或是其他任何算法进行遍历，我们真正要做的事情内容被更好地体现在代码中。</p><h2 id="2-2-流式思想概述"><a href="#2-2-流式思想概述" class="headerlink" title="2.2 流式思想概述"></a>2.2 流式思想概述</h2><p><strong>注意：请暂时忘记对传统IO流的固有印象！</strong></p><p>整体来看，流式思想类似于工厂车间的“<strong>生产流水线</strong>”。</p><p><img src="/../images/02-%E6%B5%81%E6%B0%B4%E7%BA%BF.jpeg"></p><p>当需要对多个元素进行操作（特别是多步操作）的时候，考虑到性能及便利性，我们应该首先拼好一个“模型”步骤方案，然后再按照方案去执行它。</p><p><img src="/../images/01-%E6%B5%81%E5%BC%8F%E6%80%9D%E6%83%B3%E7%A4%BA%E6%84%8F%E5%9B%BE(2).png"></p><p>这张图中展示了过滤、映射、跳过、计数等多步操作，这是一种集合元素的处理方案，而方案就是一种“函数模型”。图中的每一个方框都是一个“流”，调用指定的方法，可以从一个流模型转换为另一个流模型。而最右侧的数字3是最终结果。</p><p>这里的<code>filter</code>、<code>map</code>、<code>skip</code>都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法<code>count</code>执行的时候，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。</p><blockquote><p>备注：“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</p></blockquote><h2 id="2-3-获取流方式"><a href="#2-3-获取流方式" class="headerlink" title="2.3 获取流方式"></a>2.3 获取流方式</h2><p><code>java.util.stream.Stream&lt;T&gt;</code>是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）</p><p>获取一个流非常简单，有以下几种常用的方式：</p><ul><li>所有的<code>Collection</code>集合都可以通过<code>stream</code>默认方法获取流；</li><li><code>Stream</code>接口的静态方法<code>of</code>可以获取数组对应的流。</li></ul><p><strong>方式1 : 根据Collection获取流</strong></p><p>首先，<code>java.util.Collection</code>接口中加入了default方法<code>stream</code>用来获取流，所以其所有实现类均可获取流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04GetStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = set.stream();</span><br><span class="line"></span><br><span class="line">        Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream3 = vector.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式2 : 根据Map获取流</strong></p><p><code>java.util.Map</code>接口不是<code>Collection</code>的子接口，且其K-V数据结构不符合流元素的单一特征，所以获取对应的流需要分key、value或entry等情况：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05GetStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; keyStream = map.keySet().stream();</span><br><span class="line">        Stream&lt;String&gt; valueStream = map.values().stream();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式3 : 根据数组获取流</strong></p><p>如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，所以<code>Stream</code>接口中提供了静态方法<code>of</code>，使用很简单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06GetStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] array = &#123; <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张一元&quot;</span> &#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>备注：<code>of</code>方法的参数其实是一个可变参数，所以支持数组。</p></blockquote><h2 id="2-4-常用方法"><a href="#2-4-常用方法" class="headerlink" title="2.4 常用方法"></a>2.4 常用方法</h2><p>流模型的操作很丰富，这里介绍一些常用的API。这些方法可以被分成两种：</p><ul><li><strong>终结方法</strong>：返回值类型不再是<code>Stream</code>接口自身类型的方法，因此不再支持类似<code>StringBuilder</code>那样的链式调用。本小节中，终结方法包括<code>count</code>和<code>forEach</code>方法。</li><li><strong>非终结方法</strong>：返回值类型仍然是<code>Stream</code>接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为非终结方法。）</li></ul><h3 id="函数拼接与终结方法"><a href="#函数拼接与终结方法" class="headerlink" title="函数拼接与终结方法"></a>函数拼接与终结方法</h3><p>在上述介绍的各种方法中，凡是返回值仍然为<code>Stream</code>接口的为<strong>函数拼接方法</strong>，它们支持链式调用；而返回值不再为<code>Stream</code>接口的为<strong>终结方法</strong>，不再支持链式调用。如下表所示：</p><table><thead><tr><th>方法名</th><th>方法作用</th><th>方法种类</th><th>是否支持链式调用</th></tr></thead><tbody><tr><td>count</td><td>统计个数</td><td>终结</td><td>否</td></tr><tr><td>forEach</td><td>逐一处理</td><td>终结</td><td>否</td></tr><tr><td>filter</td><td>过滤</td><td>函数拼接</td><td>是</td></tr><tr><td>limit</td><td>取用前几个</td><td>函数拼接</td><td>是</td></tr><tr><td>skip</td><td>跳过前几个</td><td>函数拼接</td><td>是</td></tr><tr><td>map</td><td>映射</td><td>函数拼接</td><td>是</td></tr><tr><td>concat</td><td>组合</td><td>函数拼接</td><td>是</td></tr></tbody></table><blockquote><p>备注：本小节之外的更多方法，请自行参考API文档。</p></blockquote><h3 id="forEach-逐一处理"><a href="#forEach-逐一处理" class="headerlink" title="forEach : 逐一处理"></a>forEach : 逐一处理</h3><p>虽然方法名字叫<code>forEach</code>，但是与for循环中的“for-each”昵称不同，该方法<strong>并不保证元素的逐一消费动作在流中是被有序执行的</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure><p>该方法接收一个<code>Consumer</code>接口函数，会将每一个流元素交给该函数进行处理。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12StreamForEach</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        stream.forEach(s-&gt;System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="count：统计个数"><a href="#count：统计个数" class="headerlink" title="count：统计个数"></a>count：统计个数</h3><p>正如旧集合<code>Collection</code>当中的<code>size</code>方法一样，流提供<code>count</code>方法来数一数其中的元素个数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。基本使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09StreamCount</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = original.filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">        System.out.println(result.count()); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filter：过滤"><a href="#filter：过滤" class="headerlink" title="filter：过滤"></a>filter：过滤</h3><p>可以通过<code>filter</code>方法将一个流转换成另一个子集流。方法声明：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure><p>该接口接收一个<code>Predicate</code>函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p><p><strong>基本使用</strong></p><p>Stream流中的<code>filter</code>方法基本使用的代码如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07StreamFilter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = original.filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里通过Lambda表达式来指定了筛选的条件：必须姓张。</p><h3 id="limit：取用前几个"><a href="#limit：取用前几个" class="headerlink" title="limit：取用前几个"></a>limit：取用前几个</h3><p><code>limit</code>方法可以对流进行截取，只取用前n个。方法签名：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br></pre></td></tr></table></figure><p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。基本使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10StreamLimit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = original.limit(<span class="number">2</span>);</span><br><span class="line">        System.out.println(result.count()); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="skip：跳过前几个"><a href="#skip：跳过前几个" class="headerlink" title="skip：跳过前几个"></a>skip：跳过前几个</h3><p>如果希望跳过前几个元素，可以使用<code>skip</code>方法获取一个截取之后的新流：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure><p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。基本使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11StreamSkip</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = original.skip(<span class="number">2</span>);</span><br><span class="line">        System.out.println(result.count()); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="map：映射"><a href="#map：映射" class="headerlink" title="map：映射"></a>map：映射</h3><p>如果需要将流中的元素映射到另一个流中，可以使用<code>map</code>方法。方法签名：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br></pre></td></tr></table></figure><p>该接口需要一个<code>Function</code>函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p><p><strong>基本使用</strong></p><p>Stream流中的<code>map</code>方法基本使用的代码如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08StreamMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;10&quot;</span>, <span class="string">&quot;12&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line">        Stream&lt;Integer&gt; result = original.map(s-&gt;Integer.parseInt(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，<code>map</code>方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为<code>Integer</code>类对象）。</p><h3 id="concat：组合"><a href="#concat：组合" class="headerlink" title="concat：组合"></a>concat：组合</h3><p>如果有两个流，希望合并成为一个流，那么可以使用<code>Stream</code>接口的静态方法<code>concat</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span><br></pre></td></tr></table></figure><blockquote><p>备注：这是一个静态方法，与<code>java.lang.String</code>当中的<code>concat</code>方法是不同的。</p></blockquote><p>该方法的基本使用代码如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12StreamConcat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; streamA = Stream.of(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; streamB = Stream.of(<span class="string">&quot;张翠山&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; result = Stream.concat(streamA, streamB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-Stream综合案例"><a href="#2-5-Stream综合案例" class="headerlink" title="2.5 Stream综合案例"></a>2.5 Stream综合案例</h2><p>现在有两个<code>ArrayList</code>集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）<strong>依次</strong>进行以下若干操作步骤：</p><ol><li>第一个队伍只要名字为3个字的成员姓名；</li><li>第一个队伍筛选之后只要前3个人；</li><li>第二个队伍只要姓张的成员姓名；</li><li>第二个队伍筛选之后不要前2个人；</li><li>将两个队伍合并为一个队伍；</li><li>根据姓名创建<code>Person</code>对象；</li><li>打印整个队伍的Person对象信息。</li></ol><p>两个队伍（集合）的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoArrayListNames</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        one.add(<span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;宋远桥&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;苏星河&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;老子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;庄子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;孙子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;洪七公&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; two = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        two.add(<span class="string">&quot;古力娜扎&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;赵丽颖&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张二狗&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张天爱&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>Person</code>类的代码为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h3><p>使用for循环 , 示例代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoArrayListNames</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; two = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个队伍只要名字为3个字的成员姓名；</span></span><br><span class="line">        List&lt;String&gt; oneA = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : one) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">3</span>) &#123;</span><br><span class="line">                oneA.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个队伍筛选之后只要前3个人；</span></span><br><span class="line">        List&lt;String&gt; oneB = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            oneB.add(oneA.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个队伍只要姓张的成员姓名；</span></span><br><span class="line">        List&lt;String&gt; twoA = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : two) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;张&quot;</span>)) &#123;</span><br><span class="line">                twoA.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个队伍筛选之后不要前2个人；</span></span><br><span class="line">        List&lt;String&gt; twoB = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; twoA.size(); i++) &#123;</span><br><span class="line">            twoB.add(twoA.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将两个队伍合并为一个队伍；</span></span><br><span class="line">        List&lt;String&gt; totalNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        totalNames.addAll(oneB);</span><br><span class="line">        totalNames.addAll(twoB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据姓名创建Person对象；</span></span><br><span class="line">        List&lt;Person&gt; totalPersonList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : totalNames) &#123;</span><br><span class="line">            totalPersonList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(name));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印整个队伍的Person对象信息。</span></span><br><span class="line">        <span class="keyword">for</span> (Person person : totalPersonList) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person&#123;name=&#x27;宋远桥&#x27;&#125;</span><br><span class="line">Person&#123;name=&#x27;苏星河&#x27;&#125;</span><br><span class="line">Person&#123;name=&#x27;洪七公&#x27;&#125;</span><br><span class="line">Person&#123;name=&#x27;张二狗&#x27;&#125;</span><br><span class="line">Person&#123;name=&#x27;张天爱&#x27;&#125;</span><br><span class="line">Person&#123;name=&#x27;张三&#x27;&#125;</span><br></pre></td></tr></table></figure><h3 id="Stream方式"><a href="#Stream方式" class="headerlink" title="Stream方式"></a>Stream方式</h3><p>等效的Stream流式处理代码为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStreamNames</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; two = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个队伍只要名字为3个字的成员姓名；</span></span><br><span class="line">        <span class="comment">// 第一个队伍筛选之后只要前3个人；</span></span><br><span class="line">        Stream&lt;String&gt; streamOne = one.stream().filter(s -&gt; s.length() == <span class="number">3</span>).limit(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二个队伍只要姓张的成员姓名；</span></span><br><span class="line">        <span class="comment">// 第二个队伍筛选之后不要前2个人；</span></span><br><span class="line">        Stream&lt;String&gt; streamTwo = two.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).skip(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将两个队伍合并为一个队伍；</span></span><br><span class="line">        <span class="comment">// 根据姓名创建Person对象；</span></span><br><span class="line">        <span class="comment">// 打印整个队伍的Person对象信息。</span></span><br><span class="line">        Stream.concat(streamOne, streamTwo).map(s-&gt; <span class="keyword">new</span> <span class="title class_">Person</span>(s)).forEach(s-&gt;System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果完全一样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person&#123;name=&#x27;宋远桥&#x27;&#125;</span><br><span class="line">Person&#123;name=&#x27;苏星河&#x27;&#125;</span><br><span class="line">Person&#123;name=&#x27;洪七公&#x27;&#125;</span><br><span class="line">Person&#123;name=&#x27;张二狗&#x27;&#125;</span><br><span class="line">Person&#123;name=&#x27;张天爱&#x27;&#125;</span><br><span class="line">Person&#123;name=&#x27;张三&#x27;&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-收集Stream结果"><a href="#2-6-收集Stream结果" class="headerlink" title="2.6 收集Stream结果"></a>2.6 收集Stream结果</h2><p>对流操作完成之后，如果需要将其结果进行收集，例如获取对应的集合、数组等，如何操作？</p><h3 id="收集到集合中"><a href="#收集到集合中" class="headerlink" title="收集到集合中"></a>收集到集合中</h3><p>Stream流提供<code>collect</code>方法，其参数需要一个<code>java.util.stream.Collector&lt;T,A, R&gt;</code>接口对象来指定收集到哪种集合中。幸运的是，<code>java.util.stream.Collectors</code>类提供一些方法，可以作为<code>Collector</code>接口的实例：</p><ul><li><code>public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</code>：转换为<code>List</code>集合。</li><li><code>public static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()</code>：转换为<code>Set</code>集合。</li></ul><p>下面是这两个方法的基本使用代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo15StreamCollect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;10&quot;</span>, <span class="string">&quot;20&quot;</span>, <span class="string">&quot;30&quot;</span>, <span class="string">&quot;40&quot;</span>, <span class="string">&quot;50&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">        Set&lt;String&gt; set = stream.collect(Collectors.toSet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="收集到数组中"><a href="#收集到数组中" class="headerlink" title="收集到数组中"></a>收集到数组中</h3><p>Stream提供<code>toArray</code>方法来将结果放到一个数组中，由于泛型擦除的原因，返回值类型是Object[]的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] toArray();</span><br></pre></td></tr></table></figure><p>其使用场景如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo16StreamArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;10&quot;</span>, <span class="string">&quot;20&quot;</span>, <span class="string">&quot;30&quot;</span>, <span class="string">&quot;40&quot;</span>, <span class="string">&quot;50&quot;</span>);</span><br><span class="line">        Object[] objArray = stream.toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda </tag>
            
            <tag> 方法引用 </tag>
            
            <tag> Stream流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合图解</title>
      <link href="/2024/06/04/%E9%9B%86%E5%90%88%E5%9B%BE%E8%A7%A3/"/>
      <url>/2024/06/04/%E9%9B%86%E5%90%88%E5%9B%BE%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="1-List图解"><a href="#1-List图解" class="headerlink" title="1.List图解"></a>1.List图解</h3><p><img src="/../images/ArrayList.png"></p><ol><li><strong>ArrayList</strong>：<ul><li>优势：<ul><li>随机访问速度快：由于 <code>ArrayList</code> 基于数组实现，可以通过索引进行快速随机访问。</li><li>内存占用较小：相对于 <code>LinkedList</code> 和 <code>Vector</code>，<code>ArrayList</code> 内存占用较小，因为它不会维护额外的链表结构或同步开销。</li></ul></li><li>适用场景：<ul><li>当需要快速随机访问元素时，特别是按索引查找元素时，<code>ArrayList</code> 是一个很好的选择。</li><li>当元素数量相对稳定，不需要频繁进行插入和删除操作时，<code>ArrayList</code> 效率较高。</li></ul></li></ul></li><li><strong>LinkedList</strong>：<ul><li>优势：<ul><li>插入和删除操作高效：由于 <code>LinkedList</code> 基于链表实现，插入和删除操作的时间复杂度为 O(1)。</li><li>内存动态分配：<code>LinkedList</code> 在插入和删除元素时不需要重新分配内存，因此在频繁插入和删除元素的情况下，性能可能优于 <code>ArrayList</code>。</li></ul></li><li>适用场景：<ul><li>当需要频繁进行插入和删除操作时，尤其是在集合的中间位置进行操作时，<code>LinkedList</code> 是一个不错的选择。</li><li>当对内存占用不那么敏感，而对于插入和删除操作的效率要求较高时，可以考虑使用 <code>LinkedList</code>。</li></ul></li></ul></li><li><strong>Vector</strong>：<ul><li>优势：<ul><li>线程安全：<code>Vector</code> 是线程安全的，支持并发访问，所有公共方法都被 synchronized 修饰。</li><li>可增长的数组：与 <code>ArrayList</code> 类似，<code>Vector</code> 也是基于数组实现的，并且支持动态增长。</li></ul></li><li>适用场景：<ul><li>当需要在多线程环境下进行操作时，<code>Vector</code> 可以确保线程安全，适合于并发访问的场景。</li><li>尽管 <code>Vector</code> 在现代 Java 中不太常用，但如果你需要一个线程安全的动态数组，可以考虑使用 <code>Vector</code>。</li></ul></li></ul></li><li><strong>CopyOnWriteArrayList</strong>：<ul><li>优势：<ul><li>线程安全且高效的迭代：<code>CopyOnWriteArrayList</code> 是线程安全的，它通过复制原数组来实现并发更新，因此对迭代操作非常高效。</li><li>适用于读多写少的场景：由于写操作会复制整个数组，因此适用于写少、读多的场景。</li></ul></li><li>适用场景：<ul><li>当需要在读多写少的场景下保证线程安全且高效的迭代时，<code>CopyOnWriteArrayList</code> 是一个很好的选择。</li><li>例如，可以用于观察者模式中，当需要多个观察者同时观察一个对象，并且观察者只读取对象状态而不修改时。</li></ul></li></ul></li></ol><h3 id="2-Set图解"><a href="#2-Set图解" class="headerlink" title="2.Set图解"></a>2.Set图解</h3><p><img src="/../images/HashSet.png"></p><ol><li><strong>HashSet</strong>：<ul><li>优势：<ul><li>快速查找：<code>HashSet</code> 基于哈希表实现，具有快速的查找性能，平均时间复杂度为 O(1)。</li><li>不允许重复元素：<code>HashSet</code> 不允许集合中存在重复元素，保证了元素的唯一性。</li></ul></li><li>适用场景：<ul><li>当需要快速查找元素，并且不关心元素的顺序时，<code>HashSet</code> 是一个很好的选择。</li><li>适合于需要去重的场景，例如在构建索引、缓存或者判断元素是否存在时使用。</li></ul></li></ul></li><li><strong>TreeSet</strong>：<ul><li>优势：<ul><li>有序性：<code>TreeSet</code> 基于红黑树实现，可以保证元素按照自然顺序或者指定的比较器顺序排序。</li><li>支持范围查找：<code>TreeSet</code> 支持范围查询操作，例如 <code>subSet()</code>, <code>headSet()</code>, <code>tailSet()</code> 等。</li></ul></li><li>适用场景：<ul><li>当需要保持元素有序，并且进行范围查询操作时，<code>TreeSet</code> 是一个很好的选择。</li><li>适合于需要按照一定顺序遍历集合中元素的场景，例如需要按照字母顺序或者数值大小顺序进行遍历。</li></ul></li></ul></li><li><strong>LinkedHashSet</strong>：<ul><li>优势：<ul><li>有序性和快速访问：<code>LinkedHashSet</code> 同时具有 <code>HashSet</code> 的快速查找特性和 <code>LinkedHashMap</code> 的有序性，内部使用链表维护插入顺序。</li><li>迭代顺序可预测：遍历 <code>LinkedHashSet</code> 时，元素的顺序与插入顺序一致。</li></ul></li><li>适用场景：<ul><li>当需要保持元素的插入顺序，并且快速访问元素时，<code>LinkedHashSet</code> 是一个很好的选择。</li><li>适合于需要维护元素插入顺序的场景，例如LRU缓存算法中。</li></ul></li></ul></li><li><strong>CopyOnWriteArraySet</strong>：<ul><li>优势：<ul><li>线程安全：<code>CopyOnWriteArraySet</code> 是线程安全的，通过复制原数组来实现并发更新，支持高效的读操作。</li><li>适用于读多写少的场景：对集合进行写操作时，会复制整个数组，因此适用于读多写少的场景。</li></ul></li><li>适用场景：<ul><li>当需要在读多写少的场景下保证线程安全，并且需要高效的读操作时，<code>CopyOnWriteArraySet</code> 是一个很好的选择。</li><li>例如，用于缓存、事件监听器集合等需要多线程安全的场景。</li></ul></li></ul></li></ol><h3 id="3-Map图解"><a href="#3-Map图解" class="headerlink" title="3.Map图解"></a>3.Map图解</h3><p><img src="/../images/HashMap.png"></p><ol><li><strong>TreeMap</strong>：<ul><li>优势：<ul><li>有序性：<code>TreeMap</code> 基于红黑树实现，可以保持键的有序性，这使得它适用于需要按照键的顺序进行遍历和操作的场景。</li><li>支持范围查询：<code>TreeMap</code> 支持范围查询操作，例如 <code>subMap()</code>, <code>headMap()</code>, <code>tailMap()</code> 等。</li></ul></li><li>适用场景：<ul><li>当需要按照键的自然顺序或者指定的比较器顺序对键进行排序，并且进行范围查询操作时，<code>TreeMap</code> 是一个很好的选择。</li><li>适合于需要有序遍历键值对的场景，例如按照字母顺序或者数值大小顺序进行遍历。</li></ul></li></ul></li><li><strong>HashMap</strong>：<ul><li>优势：<ul><li>高性能：<code>HashMap</code> 基于哈希表实现，具有快速的插入、删除和查找操作，平均时间复杂度为 O(1)。</li><li>可变大小：<code>HashMap</code> 不限制容量，可以根据需要动态调整大小。</li></ul></li><li>适用场景：<ul><li>当需要快速插入、删除和查找键值对，并且不需要保持任何顺序时，<code>HashMap</code> 是一个很好的选择。</li><li>适合于需要高性能的哈希映射的场景，例如缓存、索引等。</li></ul></li></ul></li><li><strong>LinkedHashMap</strong>：<ul><li>优势：<ul><li>有序性：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，但内部使用链表维护插入顺序，因此可以保持插入顺序。</li><li>迭代顺序可预测：遍历 <code>LinkedHashMap</code> 时，键值对的顺序与插入顺序一致。</li></ul></li><li>适用场景：<ul><li>当需要保持键值对的插入顺序时，<code>LinkedHashMap</code> 是一个很好的选择。</li><li>适合于需要按照元素插入顺序遍历键值对的场景，例如LRU缓存算法中。</li></ul></li></ul></li><li><strong>ConcurrentHashMap</strong>：<ul><li>优势：<ul><li>线程安全：<code>ConcurrentHashMap</code> 是线程安全的哈希映射，支持并发访问而不需要额外的同步措施。</li><li>高性能：<code>ConcurrentHashMap</code> 通过分段锁机制实现高效的并发更新，可以同时支持多个写操作和多个读操作。</li></ul></li><li>适用场景：<ul><li>当需要在多线程环境下安全地进行并发访问和更新操作时，<code>ConcurrentHashMap</code> 是一个很好的选择。</li><li>适合于需要高并发性能和线程安全的场景，例如并发缓存、并行计算等。</li></ul></li></ul></li><li><strong>Hashtable</strong>：<ul><li>优势：<ul><li>线程安全：<code>Hashtable</code> 是线程安全的哈希映射，所有公共方法都是同步的，支持多线程并发访问。</li><li>可靠性：由于所有的方法都是同步的，<code>Hashtable</code> 在多线程环境下可以提供可靠的线程安全性。</li></ul></li><li>适用场景：<ul><li>当需要在多线程环境下安全地进行并发访问和更新操作，并且需要保证线程安全性和可靠性时，<code>Hashtable</code> 是一个选择。</li><li>然而，由于其同步开销较高，一般情况下 <code>ConcurrentHashMap</code> 更常被选择。</li></ul></li></ul></li><li><strong>Properties</strong>：<ul><li>优势：<ul><li>用于处理属性文件：<code>Properties</code> 是一个专门用来处理属性文件（key-value对）的集合类，通常用于配置文件的读取和写入。</li><li>字符串类型：<code>Properties</code> 的键和值都是字符串类型，适合于存储简单的配置信息。</li></ul></li><li>适用场景：<ul><li>当需要读取或者写入配置文件时，特别是简单的键值对配置信息时，<code>Properties</code> 是一个很好的选择。</li><li>适合于处理简单的文本配置文件，例如应用程序的配置信息、国际化资源文件等。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List </tag>
            
            <tag> Set </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 常用命令</title>
      <link href="/2024/06/02/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/06/02/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本命令"><a href="#一、基本命令" class="headerlink" title="一、基本命令"></a>一、基本命令</h2><h3 id="1-1-关机和重启"><a href="#1-1-关机和重启" class="headerlink" title="1.1 关机和重启"></a>1.1 关机和重启</h3><p>关机<br>    shutdown -h now        立刻关机<br>    shutdown -h 5        5分钟后关机<br>    poweroff            立刻关机<br>重启<br>    shutdown -r now        立刻重启<br>    shutdown -r 5        5分钟后重启<br>    reboot                立刻重启</p><h3 id="1-2-帮助命令"><a href="#1-2-帮助命令" class="headerlink" title="1.2 帮助命令"></a>1.2 帮助命令</h3><p>–help命令<br>  shutdown –help：<br>  ifconfig  –help：查看网卡信息</p><p>man命令（命令说明书）<br>  man shutdown<br>  注意：man shutdown打开命令说明书之后，使用按键q退出</p><p>二、目录操作命令</p><h3 id="2-1-目录切换-cd"><a href="#2-1-目录切换-cd" class="headerlink" title="2.1 目录切换 cd"></a>2.1 目录切换 cd</h3><p>命令：cd 目录  （change directory） </p><p>cd &#x2F;        切换到根目录<br>cd &#x2F;usr        切换到根目录下的usr目录<br>cd ..&#x2F;        切换到上一级目录 或者  cd ..<br>cd ~        切换到home目录<br>cd -        切换到上次访问的目录</p><h3 id="2-2-目录查看-ls-al"><a href="#2-2-目录查看-ls-al" class="headerlink" title="2.2 目录查看 ls [-al]"></a>2.2 目录查看 ls [-al]</h3><p>命令：ls [-al]    （list  -all  longs）</p><p>ls                查看当前目录下的所有目录和文件<br>ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）<br>ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）<br>ls &#x2F;dir            查看指定目录下的所有目录和文件   如：ls &#x2F;usr</p><h3 id="2-3-目录操作【增，删，改，查】"><a href="#2-3-目录操作【增，删，改，查】" class="headerlink" title="2.3 目录操作【增，删，改，查】"></a>2.3 目录操作【增，删，改，查】</h3><h4 id="2-3-1-创建目录【增】-mkdir"><a href="#2-3-1-创建目录【增】-mkdir" class="headerlink" title="2.3.1 创建目录【增】 mkdir"></a>2.3.1 创建目录【增】 mkdir</h4><p>命令：mkdir 目录  （make directory）</p><p>mkdir    aaa            在当前目录下创建一个名为aaa的目录<br>mkdir    &#x2F;usr&#x2F;aaa    在指定目录下创建一个名为aaa的目录</p><h4 id="2-3-2-删除目录或文件【删】rm"><a href="#2-3-2-删除目录或文件【删】rm" class="headerlink" title="2.3.2 删除目录或文件【删】rm"></a>2.3.2 删除目录或文件【删】rm</h4><p>命令：rm [-rf] 目录</p><p>删除文件：<br>rm 文件        删除当前目录下的文件<br>rm -f 文件    删除当前目录的的文件（不询问）</p><p>删除目录：<br>rm -r aaa    递归删除当前目录下的aaa目录<br>rm -rf aaa    递归删除当前目录下的aaa目录（不询问）</p><p>全部删除：<br>rm -rf *    将当前目录下的所有目录和文件全部删除<br>rm -rf &#x2F;*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</p><p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录&#x2F;文件&#x2F;压缩包</p><h4 id="2-3-3-目录修改【改】mv-和-cp"><a href="#2-3-3-目录修改【改】mv-和-cp" class="headerlink" title="2.3.3 目录修改【改】mv 和 cp"></a>2.3.3 目录修改【改】mv 和 cp</h4><h4 id="一、重命名目录"><a href="#一、重命名目录" class="headerlink" title="一、重命名目录"></a>一、重命名目录</h4><p>​    命令：mv 当前目录  新目录<br>​    例如：mv aaa bbb    将目录aaa改为bbb<br>​    注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行    重命名的操作</p><h4 id="二、剪切目录"><a href="#二、剪切目录" class="headerlink" title="二、剪切目录"></a>二、剪切目录</h4><p>​    命令：mv 目录名称 目录的新位置 (move )<br>​    示例：将&#x2F;usr&#x2F;tmp目录下的aaa目录剪切到 &#x2F;usr目录下面     mv &#x2F;usr&#x2F;tmp&#x2F;aaa &#x2F;usr<br>​    注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作</p><h4 id="三、拷贝目录"><a href="#三、拷贝目录" class="headerlink" title="三、拷贝目录"></a>三、拷贝目录</h4><p>​    命令：cp -r 目录名称 目录拷贝的目标位置   -r代表递归 (copy)<br>​    示例：将&#x2F;usr&#x2F;tmp目录下的aaa目录复制到 &#x2F;usr目录下面     cp &#x2F;usr&#x2F;tmp&#x2F;aaa  &#x2F;usr<br>​    注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不    用写-r递归</p><h4 id="2-3-4-搜索目录【查】find"><a href="#2-3-4-搜索目录【查】find" class="headerlink" title="2.3.4 搜索目录【查】find"></a>2.3.4 搜索目录【查】find</h4><p>命令：find 目录 参数 文件名称<br>示例：find &#x2F;usr&#x2F;tmp -name ‘a*’    查找&#x2F;usr&#x2F;tmp目录下的所有以a开头的目录或文件</p><h2 id="三、文件操作命令"><a href="#三、文件操作命令" class="headerlink" title="三、文件操作命令"></a>三、文件操作命令</h2><h2 id="3-1-文件操作【增，删，改，查】"><a href="#3-1-文件操作【增，删，改，查】" class="headerlink" title="3.1 文件操作【增，删，改，查】"></a>3.1 文件操作【增，删，改，查】</h2><h3 id="3-1-1-新建文件【增】touch"><a href="#3-1-1-新建文件【增】touch" class="headerlink" title="3.1.1 新建文件【增】touch"></a>3.1.1 新建文件【增】touch</h3><p>命令：touch 文件名<br>示例：在当前目录创建一个名为aa.txt的文件        touch  aa.txt</p><h3 id="3-1-2-删除文件-【删】-rm"><a href="#3-1-2-删除文件-【删】-rm" class="headerlink" title="3.1.2 删除文件 【删】 rm"></a>3.1.2 删除文件 【删】 rm</h3><p>命令：rm -rf 文件名 (remove      force)</p><h3 id="3-1-3-修改文件【改】-vi或vim"><a href="#3-1-3-修改文件【改】-vi或vim" class="headerlink" title="3.1.3 修改文件【改】 vi或vim"></a>3.1.3 修改文件【改】 vi或vim</h3><p>【vi编辑器的3种模式】<br>    基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：</p><h5 id="1-命令行模式command-mode）"><a href="#1-命令行模式command-mode）" class="headerlink" title="1) 命令行模式command mode）"></a>1) 命令行模式command mode）</h5><p>​      控制屏幕光标的移动，字符、字或行的删除，查找，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>​      命令行模式下的常用命令：<br>​      【1】控制光标移动：↑，↓，j<br>​      【2】删除当前行：dd<br>​      【3】查找：&#x2F;字符<br>​      【4】进入编辑模式：i o a<br>​      【5】进入底行模式：:<br>​      </p><h5 id="2-编辑模式（Insert-mode）"><a href="#2-编辑模式（Insert-mode）" class="headerlink" title="2) 编辑模式（Insert mode）"></a>2) 编辑模式（Insert mode）</h5><p>​      只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>​      编辑模式下常用命令：<br>​      【1】ESC 退出编辑模式到命令行模式；<br>​      </p><h5 id="3-底行模式（last-line-mode）"><a href="#3-底行模式（last-line-mode）" class="headerlink" title="3) 底行模式（last line mode）"></a>3) 底行模式（last line mode）</h5><p>​     将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。<br>​     底行模式下常用命令：<br>​     【1】退出编辑：   :q<br>​     【2】强制退出：   :q!<br>​     【3】保存并退出：  :wq</p><h5 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h5><p>命令：vi 文件名<br>示例：打开当前目录下的aa.txt文件     vi aa.txt 或者 vim aa.txt</p><p>注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i&#x2F;a&#x2F;o进入编辑模式。</p><h5 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h5><p>使用vi编辑器打开文件后点击按键：i ，a或者o即可进入编辑模式。</p><p>i:在光标所在字符前开始插入<br>a:在光标所在字符后开始插入<br>o:在光标所在行的下面另起一新行插入</p><h5 id="保存或者取消编辑"><a href="#保存或者取消编辑" class="headerlink" title="保存或者取消编辑"></a>保存或者取消编辑</h5><p>保存文件：</p><p>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：wq     保存并退出编辑</p><h5 id="取消编辑："><a href="#取消编辑：" class="headerlink" title="取消编辑："></a>取消编辑：</h5><p>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：q!     撤销本次修改并退出编辑</p><h3 id="3-1-4-文件的查看【查】"><a href="#3-1-4-文件的查看【查】" class="headerlink" title="3.1.4 文件的查看【查】"></a>3.1.4 文件的查看【查】</h3><p>文件的查看命令：cat&#x2F;more&#x2F;less&#x2F;tail</p><p>cat：看最后一屏</p><p>示例：使用cat查看&#x2F;etc&#x2F;sudo.conf文件，只能显示最后一屏内容<br>cat sudo.conf</p><p>more：百分比显示</p><p>示例：使用more查看&#x2F;etc&#x2F;sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看<br>more sudo.conf</p><p>less：翻页查看</p><p>示例：使用less查看&#x2F;etc&#x2F;sudo.conf文件，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看<br>less sudo.conf</p><p>tail：指定行数或者动态查看</p><p>示例：使用tail -10 查看&#x2F;etc&#x2F;sudo.conf文件的后10行，Ctrl+C结束<br>tail -10 sudo.conf</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架List&amp;Set</title>
      <link href="/2024/06/01/JavaSE%E9%AB%98%E7%BA%A7%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6List&amp;Set/"/>
      <url>/2024/06/01/JavaSE%E9%AB%98%E7%BA%A7%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6List&amp;Set/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaSE高级-集合框架List-Set"><a href="#JavaSE高级-集合框架List-Set" class="headerlink" title="JavaSE高级 集合框架List&amp;Set"></a>JavaSE高级 集合框架List&amp;Set</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li><p>泛型</p><ul><li>ArrayLIst<Integer> lists &#x3D; new ArrayList&lt;&gt;();</li></ul></li><li><p><strong>Collection集合：List , Map , Set</strong> </p><ul><li>三天的集合框架（重点内容，开发必用）</li></ul></li><li><p>Collection集合的遍历方式:</p></li><li><p>迭代器。</p><ul><li>foreach(增强for循环)</li><li>JDK 1.8开始的新技术Lambda表达式。</li></ul></li></ul><ul><li><p>数据结构</p><ul><li>是集合的底层，研究数据结构是为了选择使用某种集合。</li></ul></li><li><p>List接口</p><ul><li>元素是有序可重复有索引的。</li></ul></li><li><p>Set接口</p><ul><li>元素是无序不重复无索引的。</li></ul></li><li><p>Collections是操作集合的工具类。</p></li><li><p>把学的集合用起来：斗地主的游戏。</p></li><li><p><input disabled="" type="checkbox"> Collection集合的常用功能</p><ul><li><input disabled="" type="checkbox"> <pre><code class="properties">Collection集合作为集合的根类，它的功能是一切集合都可以直接使用的。 - public boolean add(E e)：  把给定的对象添加到当前集合中 。 - public void clear() :清空集合中所有的元素。 - public boolean remove(E e): 把给定的对象在当前集合中删除。 - public boolean contains(Object obj): 判断当前集合中是否包含给定的对象。 - public boolean isEmpty(): 判断当前集合是否为空。 - public int size(): 返回集合中元素的个数。 - public Object[] toArray(): 把集合中的元素，存储到数组中<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- [ ] 使用泛型创建集合对象</span><br><span class="line"></span><br><span class="line">  - [ ] ```java</span><br><span class="line">    ArrayList&lt;String&gt; lists = new ArrayList&lt;&gt;(); // JDK 1.7之后泛型的简化写法！</span><br><span class="line">    ArrayList&lt;Integer&gt; lists1 = new ArrayList&lt;&gt;();// JDK 1.7之后泛型的简化写法！</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p><input disabled="" type="checkbox"> 理解泛型上下限</p><ul><li><input disabled="" type="checkbox"> ? extends Car : ?必须是Car的子类或者本身 。  上限</li><li><input disabled="" type="checkbox"> ? super Car : ?必须是Car的父类或者本身 。  下限   不用的!!</li></ul></li><li><p><input disabled="" type="checkbox"> 阐述泛型通配符的作用</p><ul><li><input disabled="" type="checkbox"> ? 可以在使用泛型的时候，代表接收一切类型</li></ul></li><li><p><input disabled="" type="checkbox"> 使用迭代器对集合进行取元素</p><ul><li><input disabled="" type="checkbox"> <pre><code class="java">Iterator&lt;String&gt; it = names.iterator();while(it.hasNext())&#123;    String rs = it.next();    System.out.println(rs);&#125;<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- [ ] List集合特点</span><br><span class="line"></span><br><span class="line">  - [ ] **元素是有序，可重复的，有索引的，底层是基于数组存储元素的，查询快，增删慢！**</span><br><span class="line"></span><br><span class="line">- [ ] 常见的数据结构</span><br><span class="line"></span><br><span class="line">  - [ ] **队列： 先进先出**</span><br><span class="line">  - [ ] **栈：先进后出，后进先出**</span><br><span class="line">  - [ ] 数组：底层是连续内存区域，查询快，增删慢！</span><br><span class="line">  - [ ] **链表：元素是游离存储的，查询慢，首尾操作快！**</span><br><span class="line">  - [ ] 红黑树 （HastSet ）：增删改查都很好，可以排序，可以提高检索数据的性能！</span><br><span class="line"></span><br><span class="line">- [ ] 数组结构特点</span><br><span class="line"></span><br><span class="line">  - [ ] **内存中的连续区域，每个区间大小固定，查询快，增删慢!**</span><br><span class="line"></span><br><span class="line">- [ ] 栈结构特点</span><br><span class="line"></span><br><span class="line">  - [ ] 先进后出。</span><br><span class="line"></span><br><span class="line">- [ ] 队列结构特点</span><br><span class="line"></span><br><span class="line">  - [ ] 先进先出</span><br><span class="line"></span><br><span class="line">- [ ] 单向链表结构特点</span><br><span class="line"></span><br><span class="line">  - [ ] 元素是游离存储的，查询慢, 一端的增删操作快！</span><br><span class="line"></span><br><span class="line">- [ ] Set集合的特点</span><br><span class="line"></span><br><span class="line">  - [ ] 元素是无序，不重复，无索引，底层是基于哈希表存储元素的，曾删查的性能都很好！！</span><br><span class="line"></span><br><span class="line">- [ ] 出哈希表的特点</span><br><span class="line"></span><br><span class="line">  - [ ] JDK 1.8之前是：链表+数组</span><br><span class="line">  - [ ] JDK 1.8之后是：链表+数组+红黑树</span><br><span class="line"></span><br><span class="line">- [ ] 使用HashSet集合存储自定义元素</span><br><span class="line"></span><br><span class="line">  - [ ] Set&lt;Apple&gt; sets = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第1章 泛型</span><br><span class="line"></span><br><span class="line">## 1.1  泛型概述</span><br><span class="line"></span><br><span class="line">集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</span><br><span class="line"></span><br><span class="line">大家观察下面代码：</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">public class GenericDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Collection coll = new ArrayList();</span><br><span class="line">coll.add(&quot;abc&quot;);</span><br><span class="line">coll.add(&quot;igeek&quot;);</span><br><span class="line">coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放</span><br><span class="line">Iterator it = coll.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span><br><span class="line">String str = (String) it.next();</span><br><span class="line">System.out.println(str.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">程序在运行时发生了问题**java.lang.ClassCastException**。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了**泛型**(**Generic**)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</span><br><span class="line"></span><br><span class="line">* **泛型**：可以在类或方法中预支地使用未知的类型。</span><br><span class="line"></span><br><span class="line">&gt; tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 1.2  使用泛型的好处</span><br><span class="line"></span><br><span class="line">那么泛型带来了哪些好处呢？</span><br><span class="line"></span><br><span class="line">* 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</span><br><span class="line">* 避免了类型强转的麻烦。</span><br><span class="line"></span><br><span class="line">通过我们如下代码体验一下：</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">public class GenericDemo2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Collection&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(&quot;abc&quot;);</span><br><span class="line">        list.add(&quot;igeek&quot;);</span><br><span class="line">        // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span><br><span class="line">        // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        while(it.hasNext())&#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">&gt; tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 1.3  泛型的定义与使用</span><br><span class="line"></span><br><span class="line">我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</span><br><span class="line"></span><br><span class="line">泛型，用来灵活地将数据类型应用到不同的**类、方法、接口**当中。将数据类型作为参数进行传递。</span><br><span class="line"></span><br><span class="line">### 1.3.1 定义和使用含有泛型的类</span><br><span class="line"></span><br><span class="line">定义格式：</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">例如，API中的ArrayList集合：</span><br><span class="line"></span><br><span class="line">泛型在定义的时候不具体，使用的时候才变得具体。在使用的时候确定泛型的具体数据类型。</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">class ArrayList&lt;E&gt;&#123; </span><br><span class="line">    public boolean add(E e)&#123; &#125;</span><br><span class="line"></span><br><span class="line">    public E get(int index)&#123; &#125;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">使用泛型： 即什么时候确定泛型。</span><br><span class="line"></span><br><span class="line">**在创建对象的时候确定泛型**</span><br><span class="line"></span><br><span class="line"> 例如，`ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();`</span><br><span class="line"></span><br><span class="line">此时，变量E的值就是String类型,那么我们的类型就可以理解为：</span><br><span class="line"></span><br><span class="line">~~~java </span><br><span class="line">class ArrayList&lt;String&gt;&#123; </span><br><span class="line">     public boolean add(String e)&#123; &#125;</span><br><span class="line"></span><br><span class="line">     public String get(int index)&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">再例如，`ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();`</span><br><span class="line"></span><br><span class="line">此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">class ArrayList&lt;Integer&gt; &#123; </span><br><span class="line">     public boolean add(Integer e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">     public Integer get(int index) &#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###  1.3.2 含有泛型的方法</span><br><span class="line"></span><br><span class="line">定义格式：</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">例如，</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">public class MyGenericMethod &#123;  </span><br><span class="line">    public &lt;MVP&gt; void show(MVP mvp) &#123;</span><br><span class="line">    System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public &lt;MVP&gt; MVP show2(MVP mvp) &#123;</span><br><span class="line">    return mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">**调用方法时，确定泛型的类型**</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">public class GenericMethodDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建对象</span><br><span class="line">        MyGenericMethod mm = new MyGenericMethod();</span><br><span class="line">        // 演示看方法提示</span><br><span class="line">        mm.show(&quot;aaa&quot;);</span><br><span class="line">        mm.show(123);</span><br><span class="line">        mm.show(12.45);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 1.3.3 含有泛型的接口</span><br><span class="line"></span><br><span class="line">定义格式：</span><br><span class="line"></span><br><span class="line">~~~</span><br><span class="line">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">例如，</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">public interface MyGenericInterface&lt;E&gt;&#123;</span><br><span class="line">public abstract void add(E e);</span><br><span class="line"></span><br><span class="line">public abstract E getE();  </span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">使用格式：</span><br><span class="line"></span><br><span class="line">**1、定义类时确定泛型的类型**</span><br><span class="line"></span><br><span class="line">例如</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123;</span><br><span class="line">@Override</span><br><span class="line">    public void add(String e) &#123;</span><br><span class="line">        // 省略...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String getE() &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">此时，泛型E的值就是String类型。</span><br><span class="line"></span><br><span class="line"> **2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型**</span><br><span class="line"></span><br><span class="line"> 例如</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123;</span><br><span class="line">@Override</span><br><span class="line">public void add(E e) &#123;</span><br><span class="line">        // 省略...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public E getE() &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line">确定泛型：</span><br><span class="line"></span><br><span class="line">~~~java</span><br><span class="line">/*</span><br><span class="line"> * 使用</span><br><span class="line"> */</span><br><span class="line">public class GenericInterface &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = new MyImp2&lt;String&gt;();  </span><br><span class="line">        my.add(&quot;aa&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 1.4  泛型通配符</span><br><span class="line"></span><br><span class="line">当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</span><br><span class="line"></span><br><span class="line">### 1.4.1 通配符基本使用</span><br><span class="line"></span><br><span class="line">泛型的通配符:**不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。**</span><br><span class="line"></span><br><span class="line">此时只能接受数据,不能往该集合中存储数据。</span><br><span class="line"></span><br><span class="line">举个例子大家理解使用即可：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line">public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;</span><br><span class="line">// ？代表可以接收任意类型</span><br><span class="line">泛型不存在继承关系 Collection&lt;Object&gt; list = new ArrayList&lt;String&gt;();这种是错误的</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h3 id="1-4-2-通配符高级使用"><a href="#1-4-2-通配符高级使用" class="headerlink" title="1.4.2 通配符高级使用"></a>1.4.2 通配符高级使用</h3><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement2</span><span class="params">(Collection&lt;? <span class="built_in">super</span> Number&gt; coll)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="第2章-Collection集合"><a href="#第2章-Collection集合" class="headerlink" title="第2章 Collection集合"></a>第2章 Collection集合</h1><h2 id="2-1-集合概述"><a href="#2-1-集合概述" class="headerlink" title="2.1 集合概述"></a>2.1 集合概述</h2><ul><li><p><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</p><p>​集合和数组既然都是容器，它们有什么区别呢？</p></li><li><p>数组的长度是固定的。集合的长度是可变的。</p></li><li><p>数组中存储的是同一类型的元素，可以存储任意类型数据。集合存储的都是引用数据类型。如果想存储基本类型数据需要存储对应的包装类型。</p></li></ul><h2 id="2-2-集合常用类的继承体系"><a href="#2-2-集合常用类的继承体系" class="headerlink" title="2.2  集合常用类的继承体系"></a>2.2  集合常用类的继承体系</h2><p>Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.LinkedHashSet</code>。</p><p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述集合常用类的继承体系</p><p><img src="/../images/Collection%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE.jpg"></p><p>注意:这张图只是我们常用的集合有这些，不是说就只有这些集合。</p><p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p><h2 id="2-3-Collection-常用API"><a href="#2-3-Collection-常用API" class="headerlink" title="2.3 Collection 常用API"></a>2.3 Collection 常用API</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(Object obj)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中</li></ul><blockquote><p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p></blockquote><h1 id="第3章-Iterator迭代器"><a href="#第3章-Iterator迭代器" class="headerlink" title="第3章 Iterator迭代器"></a>第3章 Iterator迭代器</h1><h2 id="3-1-Iterator接口"><a href="#3-1-Iterator接口" class="headerlink" title="3.1 Iterator接口"></a>3.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p>下面介绍一下迭代的概念：</p><ul><li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li></ul><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">&quot;串串星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;吐槽星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;汪星人&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips: </p><ol><li>在进行集合元素获取时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会抛出java.util.NoSuchElementException没有集合元素异常。</li><li>在进行集合元素获取时，如果添加或移除集合中的元素 , 将无法继续迭代 , 将会抛出&#x3D;&#x3D;ConcurrentModificationException&#x3D;&#x3D;并发修改异常.</li></ol></blockquote><h2 id="3-2-迭代器的实现原理"><a href="#3-2-迭代器的实现原理" class="headerlink" title="3.2 迭代器的实现原理"></a>3.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p><p><img src="/../images/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86%E5%9B%BE.bmp"></p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h1 id="第4章-数据结构"><a href="#第4章-数据结构" class="headerlink" title="第4章 数据结构"></a>第4章 数据结构</h1><h2 id="4-1-数据结构介绍"><a href="#4-1-数据结构介绍" class="headerlink" title="4.1 数据结构介绍"></a>4.1 数据结构介绍</h2><p>数据结构 : 数据用什么样的方式组合在一起。</p><h2 id="4-2-常见数据结构"><a href="#4-2-常见数据结构" class="headerlink" title="4.2 常见数据结构"></a>4.2 常见数据结构</h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li></ul><p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p><ul><li>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</li><li>栈的入口、出口的都是栈的顶端位置。</li></ul><p>这里两个名词需要注意：</p><ul><li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li><li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li></ul><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul><li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li><li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li></ul><p><img src="/../images/%E9%98%9F%E5%88%97.png"></p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li></ul><p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p><p><img src="/../images/%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%BF%AB.png"></p></li><li><p>增删元素慢</p></li><li><p><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图<img src="/image/%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0.png"></p></li><li><p><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图<img src="/image/%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4.png"></p></li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li><p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</p><p><img src="/../images/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9.png"></p></li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p></li><li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p></li><li><p>增删元素快：</p><p><img src="/../images/%E9%93%BE%E8%A1%A8.png">树数据结构</p><p>树是有很多节点组成的</p></li></ul><h2 id="4-3-树基本结构介绍"><a href="#4-3-树基本结构介绍" class="headerlink" title="4.3 树基本结构介绍"></a>4.3 树基本结构介绍</h2><p>树具有的特点：</p><ol><li>每一个节点有零个或者多个子节点</li><li>没有父节点的节点称之为根节点，<strong>一个树最多有一个根节点。</strong></li><li>每一个非根节点有且只有一个父节点</li></ol><p><img src="/../images/1562637870270.png" alt="1562637870270"> </p><table><thead><tr><th>名词</th><th>含义</th></tr></thead><tbody><tr><td>节点</td><td>指树中的一个元素</td></tr><tr><td>节点的度</td><td>节点拥有的子树的个数，二叉树的度不大于2</td></tr><tr><td>叶子节点</td><td>度为0的节点，也称之为终端结点</td></tr><tr><td>高度</td><td>叶子节点的高度为1，叶子结点的父节点高度为2，以此类推，根节点的高度最高</td></tr><tr><td>层</td><td>根节点在第一层，以此类推</td></tr><tr><td>父节点</td><td>若一个节点含有子节点，则这个节点称之为其子节点的父节点</td></tr><tr><td>子节点</td><td>子节点是父节点的下一层节点</td></tr><tr><td>兄弟节点</td><td>拥有共同父节点的节点互称为兄弟节点</td></tr></tbody></table><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>如果树中的每个节点的子节点的个数不超过2，那么该树就是一个二叉树。</p><p><img src="/../images/1565609702432.png" alt="1565609702432"></p><h3 id="二叉查找树-二叉排序树"><a href="#二叉查找树-二叉排序树" class="headerlink" title="二叉查找树&#x2F;二叉排序树"></a>二叉查找树&#x2F;二叉排序树</h3><p>二叉查找树的特点：</p><ol><li>左子树上所有的节点的值均小于等于他的根节点的值</li><li>右子树上所有的节点值均大于或者等于他的根节点的值</li><li>每一个子节点最多有两个子树</li></ol><p>案例演示(20,18,23,22,17,24,19)数据的存储过程；</p><p><img src="/../images/1565611710800.png" alt="1565611710800"></p><p><strong>增删改查的性能都很高！！！</strong></p><p>遍历获取元素的时候可以按照”左中右”的顺序进行遍历；</p><p>注意：二叉查找树存在的问题：会出现”瘸子”的现象，影响查询效率。</p><p><img src="/../images/1565611927771.png" alt="1565611927771"></p><h3 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a><strong>二叉树的遍历方式</strong></h3><p>二叉树的遍历方式包括三种基本方式：前序遍历、中序遍历和后序遍历。这些遍历方式都是深度优先搜 </p><p>索（DFS）的一种，它们描述了访问和处理树节点的顺序。 </p><p>1.前序遍历（Preorder Traversal）: </p><p>遍历顺序：根节点 -&gt; 左子树 -&gt; 右子树 </p><p>具体操作：首先访问根节点，然后递归地对左子树和右子树进行前序遍历。 </p><p>2.中序遍历（Inorder Traversal）: </p><p>遍历顺序：左子树 -&gt; 根节点 -&gt; 右子树 </p><p>具体操作：首先递归地对左子树进行中序遍历，然后访问根节点，最后递归地对右子树进行中序遍历。 </p><p>3.后序遍历（Postorder Traversal）: </p><p>遍历顺序：左子树 -&gt; 右子树 -&gt; 根节点 </p><p>具体操作：首先递归地对左子树和右子树进行后序遍历，然后访问根节点。</p><p>前序遍历：1 2 4 5 7 8 3 6 </p><p>中序遍历：4 2 7 5 8 1 3 6 </p><p>后序遍历：4 7 8 5 2 6 3 1 </p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>基于查找二叉树，但是让树不要太高，尽量让树的元素均衡分布。这样综合性能就高了</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>为了避免出现”瘸子”的现象，减少树的高度，提高我们的搜索效率，又存在一种树的结构：”平衡二叉树”</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p><strong>它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</strong></p><p>如下图所示：</p><p><img src="/../images/1562642409744.png" alt="1565611927771"></p><p>如下图所示，左图是一棵平衡二叉树，根节点10，左右两子树的高度差是1，而右图，虽然根节点左右两子树高度差是0，但是右子树15的左右子树高度差为2，不符合定义，所以右图不是一棵平衡二叉树。</p><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>在构建一棵平衡二叉树的过程中，当有新的节点要插入时，检查是否因插入后而破坏了树的平衡，如果是，则需要做旋转去改变树的结构。</p><p>&#x3D;&#x3D;左旋：&#x3D;&#x3D;</p><p><strong>左旋就是将节点的右支往左拉，右子节点变成父节点，并把晋升之后多余的左子节点出让给降级节点的右子节点；</strong></p><p>&#x3D;&#x3D;右旋：&#x3D;&#x3D;</p><p><strong>将节点的左支往右拉，左子节点变成了父节点，并把晋升之后多余的右子节点出让给降级节点的左子节点</strong></p><p>举个例子，像上图是否平衡二叉树的图里面，左图在没插入前”19”节点前，该树还是平衡二叉树，但是在插入”19”后，导致了”15”的左右子树失去了”平衡”，</p><p>所以此时可以将”15”节点进行左旋，让”15”自身把节点出让给”17”作为”17”的左树，使得”17”节点左右子树平衡，而”15”节点没有子树，左右也平衡了。</p><p>如下图：</p><p><img src="/../images/1562644020804.png" alt="1562644020804"> </p><p>由于在构建平衡二叉树的时候，当有<strong>新节点插入</strong>时，都会判断插入后时候平衡，这说明了插入新节点前，都是平衡的，也即高度差绝对值不会超过1。当新节点插入后，有可能会有导致树不平衡，这时候就需要进行调整，而可能出现的情况就有4种，分别称作<strong>左左，左右，右左，右右</strong>。</p><h5 id="左左"><a href="#左左" class="headerlink" title="左左"></a>左左</h5><p>左左即为在原来平衡的二叉树上，在节点的左子树的左子树下，有新节点插入，导致节点的左右子树的高度差为2，如下即为”10”节点的左子树”7”，的左子树”4”，插入了节点”5”或”3”导致失衡。</p><p><img src="/../images/1562644117681.png" alt="1562644117681"> </p><p>左左调整其实比较简单，只需要对节点进行右旋即可，如下图，对节点”10”进行右旋，</p><p><img src="/../images/1562645661857.png" alt="1562645661857"> </p><p><img src="/../images/1562645709201.png" alt="1562645709201"> </p><h5 id="左右"><a href="#左右" class="headerlink" title="左右"></a>左右</h5><p>左右即为在原来平衡的二叉树上，在节点的左子树的右子树下，有新节点插入，导致节点的左右子树的高度差为2，如上即为”11”节点的左子树”7”，的右子树”9”，插入了节点”10”或”8”导致失衡。</p><p><img src="/../images/1562644916480.png" alt="1562644916480"> </p><p>左右的调整就不能像左左一样，进行一次旋转就完成调整。我们不妨先试着让左右像左左一样对”11”节点进行右旋，结果图如下，右图的二叉树依然不平衡，而右图就是接下来要讲的右左，即左右跟右左互为镜像，左左跟右右也互为镜像。</p><p><img src="/../images/1562645170454.png" alt="1562645170454"> </p><p>左右这种情况，进行一次旋转是不能满足我们的条件的，正确的调整方式是，将左右进行第一次旋转，将左右先调整成左左，然后再对左左进行调整，从而使得二叉树平衡。</p><p>即先对上图的节点”7”进行左旋，使得二叉树变成了左左，之后再对”11”节点进行右旋，此时二叉树就调整完成，如下图:</p><p><img src="/../images/1562645351977.png" alt="1562645351977"> </p><h5 id="右左"><a href="#右左" class="headerlink" title="右左"></a>右左</h5><p>右左即为在原来平衡的二叉树上，在节点的右子树的左子树下，有新节点插入，导致节点的左右子树的高度差为2，如上即为”11”节点的右子树”15”，的左子树”13”，插入了节点”12”或”14”导致失衡。</p><p><img src="/../images/1562645765291.png" alt="1562645765291"> </p><p>前面也说了，右左跟左右其实互为镜像，所以调整过程就反过来，先对节点”15”进行右旋，使得二叉树变成右右，之后再对”11”节点进行左旋，此时二叉树就调整完成，如下图:</p><p><img src="/../images/1562645894833.png" alt="1562645894833"> </p><h5 id="右右"><a href="#右右" class="headerlink" title="右右"></a>右右</h5><p>右右即为在原来平衡的二叉树上，在节点的右子树的右子树下，有新节点插入，导致节点的左右子树的高度差为2，如下即为”11”节点的右子树”13”，的左子树”15”，插入了节点”14”或”19”导致失衡。</p><p><img src="/../images/1562645951703.png" alt="1562645951703"> </p><p>右右只需对节点进行一次左旋即可调整平衡，如下图，对”11”节点进行左旋。</p><p><img src="/../images/1562646135227.png" alt="1562646135227"> </p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>就是平衡的二叉查找树 +  2-3树 &#x2F;2-3-4树</p><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>​红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构，它是在1972年由Rudolf Bayer发明的，当时被称之为平衡二叉B树，后来，在1978年被Leoj.Guibas和Robert Sedgewick修改为如今的”红黑树”。</p><p>​它是一种特殊的二叉查找树，红黑树的每一个节点上都有存储位表示节点的颜色，可以是红或者黑；红黑树不是高度平衡的，它的平衡是通过”红黑树的特性”进行实现的；</p><h4 id="红黑树的特性"><a href="#红黑树的特性" class="headerlink" title="红黑树的特性"></a>红黑树的特性</h4><ol><li>每一个节点或是红色的，或者是黑色的。</li><li>根节点必须是黑色</li><li>每个叶节点(Nil)是黑色的；（如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点）</li><li>如果某一个节点是红色，那么它的子节点必须是黑色(不能出现两个红色节点相连的情况)</li><li>对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点；</li></ol><p>如下图所示就是一个</p><p><img src="/../images/1562653205543.png" alt="1562653205543"> </p><p>在进行元素插入的时候，和之前一样； 每一次插入完毕以后，使用黑色规则进行校验，如果不满足红黑规则，就需要通过变色，左旋和右旋来调整树，使其满足红黑规则；</p><h1 id="第5章-List接口"><a href="#第5章-List接口" class="headerlink" title="第5章 List接口"></a>第5章 List接口</h1><p>我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？</p><p>接下来，我们一起学习Collection中的常用几个子类（<code>java.util.List</code>集合、<code>java.util.Set</code>集合）。</p><h2 id="5-1-List接口介绍"><a href="#5-1-List接口介绍" class="headerlink" title="5.1 List接口介绍"></a>5.1 List接口介绍</h2><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p><p>看完API，我们总结一下：</p><p>List接口特点：</p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><h2 id="5-2-List接口中常用方法"><a href="#5-2-List接口中常用方法" class="headerlink" title="5.2 List接口中常用方法"></a>5.2 List接口中常用方法</h2><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><p>List集合特有的方法都是跟索引相关，我们在基础班都学习过。</p><blockquote><p>tips:我们之前学习Colletion体系的时候，发现List集合下有很多集合，它们的存储结构不同，这样就导致了这些集合它们有各自的特点，供我们在不同的环境下使用，那么常见的数据结构有哪些呢？在下一章我们来介绍：</p></blockquote><h2 id="5-3-ArrayList集合"><a href="#5-3-ArrayList集合" class="headerlink" title="5.3 ArrayList集合"></a>5.3 ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p><p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p><h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List作业</span><br><span class="line"><span class="comment">//1.模拟登陆，编写用户类，测试类。</span></span><br><span class="line">  <span class="number">1</span>&gt;.给集合中存储<span class="number">5</span>个用户对象。</span><br><span class="line">  <span class="number">2</span>&gt;.从控制台输入用户名和密码，和集合中的对象信息进行比较，相同表示成功，不同表示失败。</span><br><span class="line">  <span class="number">3</span>&gt;.有三次输入机会。</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.去除ArrayList集合中重复元素</span></span><br><span class="line">  <span class="number">1</span>&gt;.存入字符串元素</span><br><span class="line">  <span class="number">2</span>&gt;.存入自定义对象元素（如Person对象）  </span><br><span class="line">    </span><br><span class="line"><span class="comment">//3.数组与集合之间转换    </span></span><br></pre></td></tr></table></figure><h2 id="5-4-LinkedList集合"><a href="#5-4-LinkedList集合" class="headerlink" title="5.4 LinkedList集合"></a>5.4 LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><blockquote><p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p></blockquote><p><img src="/../images/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png"></p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为<strong>了解即可</strong>：</p><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04LinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">method4();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  void push(E e)： 压入。把元素添加到集合的第一个位置。</span></span><br><span class="line"><span class="comment"> *  E pop()： 弹出。把第一个元素删除，然后返回这个元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//创建LinkedList对象</span></span><br><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">list.add(<span class="string">&quot;达尔文&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;达芬奇&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;达尔优&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list:&quot;</span> + list);</span><br><span class="line"><span class="comment">//调用push在集合的第一个位置添加元素</span></span><br><span class="line"><span class="comment">//list.push(&quot;爱迪生&quot;);</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;list:&quot; + list);//[爱迪生, 达尔文, 达芬奇, 达尔优]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//E pop()： 弹出。把第一个元素删除，然后返回这个元素。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> list.pop();</span><br><span class="line">System.out.println(<span class="string">&quot;value:&quot;</span> + value);<span class="comment">//达尔文</span></span><br><span class="line">System.out.println(<span class="string">&quot;list:&quot;</span> + list);<span class="comment">//[达芬奇，达尔优]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * E removeFirst()：删除第一个元素</span></span><br><span class="line"><span class="comment"> * E removeLast()：删除最后一个元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//创建LinkedList对象</span></span><br><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">list.add(<span class="string">&quot;达尔文&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;达芬奇&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;达尔优&quot;</span>);</span><br><span class="line"><span class="comment">//删除集合的第一个元素</span></span><br><span class="line"><span class="comment">//String value = list.removeFirst();</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;value:&quot; + value);//达尔文</span></span><br><span class="line"><span class="comment">//System.out.println(&quot;list:&quot; + list);//[达芬奇，达尔优]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除最后一个元素</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> list.removeLast();</span><br><span class="line">System.out.println(<span class="string">&quot;value:&quot;</span> + value);<span class="comment">//达尔优</span></span><br><span class="line">System.out.println(<span class="string">&quot;list:&quot;</span> + list);<span class="comment">//[达尔文， 达芬奇]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * E getFirst()： 获取集合中的第一个元素</span></span><br><span class="line"><span class="comment"> * E getLast()： 获取集合中的最后一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//创建LinkedList对象</span></span><br><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">list.add(<span class="string">&quot;达尔文&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;达芬奇&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;达尔优&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;list:&quot;</span> + list);</span><br><span class="line"><span class="comment">//获取集合中的第一个元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;第一个元素是：&quot;</span> + list.getFirst());</span><br><span class="line"><span class="comment">//获取集合中的最后一个元素怒</span></span><br><span class="line">System.out.println(<span class="string">&quot;最后一个元素是：&quot;</span> + list.getLast());</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * void addFirst(E e)： 在集合的开头位置添加元素。</span></span><br><span class="line"><span class="comment"> * void addLast(E e)： 在集合的尾部添加元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//创建LinkedList对象</span></span><br><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">list.add(<span class="string">&quot;达尔文&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;达芬奇&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;达尔优&quot;</span>);</span><br><span class="line"><span class="comment">//打印这个集合</span></span><br><span class="line">System.out.println(<span class="string">&quot;list:&quot;</span> + list);<span class="comment">//[达尔文, 达芬奇, 达尔优]</span></span><br><span class="line"><span class="comment">//调用addFirst添加元素</span></span><br><span class="line">list.addFirst(<span class="string">&quot;曹操&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list:&quot;</span> + list);<span class="comment">//[曹操, 达尔文, 达芬奇, 达尔优]</span></span><br><span class="line"><span class="comment">//调用addLast方法添加元素</span></span><br><span class="line">list.addLast(<span class="string">&quot;大乔&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;list:&quot;</span> + list);<span class="comment">//[曹操, 达尔文, 达芬奇, 达尔优, 大乔]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="课堂练习-1"><a href="#课堂练习-1" class="headerlink" title="课堂练习"></a>课堂练习</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//练习1：用LinkedList集合，模拟队列操作(存入的元素是Person对象)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//练习2：用LinkedList集合，模拟堆栈操作(存入的元素是Person对象)</span></span><br></pre></td></tr></table></figure><h2 id="5-5-ArrayList数组和LinkedList链表实现的原理"><a href="#5-5-ArrayList数组和LinkedList链表实现的原理" class="headerlink" title="5.5 ArrayList数组和LinkedList链表实现的原理"></a>5.5 ArrayList数组和LinkedList链表实现的原理</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>数组实现的特点：查询快，增删慢</p><p>原因：</p><p>​查询快：由于数组的索引支持，那么可以通过索引直接计算出元素的地址值，因此就可以直接通过元素的地址值获取到指定的元素</p><p>​增删慢：由于在添加元素的时候，实际上底层会先创建一个新数组(新数组的长度为原数组的长度+1)，那么在添加新元素的时候，先需要对数组中原有的数据进行拷贝，其次在末尾进行添加新的元素。因此，这样操作的效率的极低的(删除元素 刚好和添加的操作相反)</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>链表结构：查询慢，增删快</p><p>查询慢：由于不能直接找到元素的地址，需要上一个元素推导出下一个元素的地址，这种查询速度较慢。</p><p>增删快：在添加的时候，只需要更改元素所记录的地址值即可</p><h1 id="第6章-Set接口"><a href="#第6章-Set接口" class="headerlink" title="第6章 Set接口"></a>第6章 Set接口</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口都会以某种规则保证存入的元素不出现重复。</p><p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>、<code>java.util.TreeSet</code>这两个集合。</p><blockquote><p>tips:Set集合取出元素的方式可以采用：迭代器、增强for。</p></blockquote><h2 id="6-1-HashSet集合介绍"><a href="#6-1-HashSet集合介绍" class="headerlink" title="6.1 HashSet集合介绍"></a>6.1 HashSet集合介绍</h2><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不能保证不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，由于我们暂时还未学习，先做了解。</p><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存储和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建 Set集合</span></span><br><span class="line">        HashSet&lt;String&gt;  set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;cba&quot;</span>));</span><br><span class="line">        set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;bac&quot;</span>); </span><br><span class="line">        set.add(<span class="string">&quot;cba&quot;</span>);  </span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下，说明集合中不能存储重复元素：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cba</span><br><span class="line">abc</span><br><span class="line">bac</span><br></pre></td></tr></table></figure><blockquote><p>tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p></blockquote><h2 id="6-2-HashSet集合存储数据的结构（哈希表）"><a href="#6-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="6.2  HashSet集合存储数据的结构（哈希表）"></a>6.2  HashSet集合存储数据的结构（哈希表）</h2><p>什么是哈希表呢？</p><p>在<strong>JDK1.8</strong>之前，哈希表底层采用<strong>数组+链表</strong>实现，即使用数组处理冲突，同一hash值的链表都存储在一个数组里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。</p><p>而<strong>JDK1.8</strong>中，哈希表存储采用<strong>数组+链表+红黑树</strong>实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。<img src="/image/%E5%93%88%E5%B8%8C%E8%A1%A8.png"> </p><p>看到这张图就有人要问了，这个是怎么存储的呢？</p><p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p><p><img src="/../images/%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p><h2 id="6-3-HashSet存储自定义类型元素"><a href="#6-3-HashSet存储自定义类型元素" class="headerlink" title="6.3  HashSet存储自定义类型元素"></a>6.3  HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一.</p><p>创建自定义Student类:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get/set</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">               Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建测试类:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象   该集合中存储 Student类型对象</span></span><br><span class="line">        HashSet&lt;Student&gt; stuSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Student&gt;();</span><br><span class="line">        <span class="comment">//存储 </span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;于谦&quot;</span>, <span class="number">43</span>);</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;郭德纲&quot;</span>, <span class="number">44</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;于谦&quot;</span>, <span class="number">43</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;郭麒麟&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student stu2 : stuSet) &#123;</span><br><span class="line">            System.out.println(stu2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">Student [name=郭德纲, age=<span class="number">44</span>]</span><br><span class="line">Student [name=于谦, age=<span class="number">43</span>]</span><br><span class="line">Student [name=郭麒麟, age=<span class="number">23</span>]</span><br></pre></td></tr></table></figure><h2 id="6-4-LinkedHashSet"><a href="#6-4-LinkedHashSet" class="headerlink" title="6.4 LinkedHashSet"></a>6.4 LinkedHashSet</h2><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p><p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p><p>演示代码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSetDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;();</span><br><span class="line">set.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;bbc&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">  bbb</span><br><span class="line">  aaa</span><br><span class="line">  abc</span><br><span class="line">  bbc</span><br></pre></td></tr></table></figure><h2 id="6-5-TreeSet集合"><a href="#6-5-TreeSet集合" class="headerlink" title="6.5 TreeSet集合"></a>6.5 TreeSet集合</h2><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h3><p>TreeSet集合是Set接口的一个实现类,底层依赖于TreeMap,是一种基于<strong>红黑树</strong>的实现,其特点为：</p><ol><li>元素唯一</li><li>元素没有索引</li><li>使用元素的<a href="../../java/lang/Comparable.html">自然顺序</a>对元素进行排序，或者根据创建 TreeSet 时提供的 <a href="../../java/util/Comparator.html"><code>Comparator</code></a> 比较器<br>进行排序，具体取决于使用的构造方法：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span>：根据其元素的自然排序进行排序</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;E&gt; comparator)</span>:    根据指定的比较器进行排序</span><br></pre></td></tr></table></figure><h3 id="2-演示"><a href="#2-演示" class="headerlink" title="2. 演示"></a>2. 演示</h3><p>案例演示<strong>自然排序</strong>(20,18,23,22,17,24,19):</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//无参构造,默认使用元素的自然顺序进行排序</span></span><br><span class="line">TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line">set.add(<span class="number">20</span>);</span><br><span class="line">set.add(<span class="number">18</span>);</span><br><span class="line">  set.add(<span class="number">23</span>);</span><br><span class="line">  set.add(<span class="number">22</span>);</span><br><span class="line">  set.add(<span class="number">17</span>);</span><br><span class="line">  set.add(<span class="number">24</span>);</span><br><span class="line">  set.add(<span class="number">19</span>);</span><br><span class="line">  System.out.println(set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">控制台的输出结果为:</span><br><span class="line">[<span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>]</span><br></pre></td></tr></table></figure><p>案例演示<strong>比较器排序</strong>(20,18,23,22,17,24,19):</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//有参构造,传入比较器,使用比较器对元素进行排序</span></span><br><span class="line">  TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">      <span class="comment">//元素前 - 元素后 : 升序</span></span><br><span class="line">      <span class="comment">//元素后 - 元素前 : 降序</span></span><br><span class="line">      <span class="keyword">return</span> o2 - o1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  set.add(<span class="number">20</span>);</span><br><span class="line">  set.add(<span class="number">18</span>);</span><br><span class="line">  set.add(<span class="number">23</span>);</span><br><span class="line">  set.add(<span class="number">22</span>);</span><br><span class="line">  set.add(<span class="number">17</span>);</span><br><span class="line">  set.add(<span class="number">24</span>);</span><br><span class="line">  set.add(<span class="number">19</span>);</span><br><span class="line">  System.out.println(set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">控制台的输出结果为:</span><br><span class="line">[<span class="number">24</span>, <span class="number">23</span>, <span class="number">22</span>, <span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>]</span><br></pre></td></tr></table></figure><h2 id="6-6-课堂练习"><a href="#6-6-课堂练习" class="headerlink" title="6.6 课堂练习"></a>6.6 课堂练习</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//练习1：求一个字符串&quot;aiodjl;hriWFUADJSV123UEHiowfjnivowe&quot;中一共有几个不重复的字母,区分大小写,如a,A算两个字符 （HashSet）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//练习2：TreeSet练习将字符串中的数值进行排序。例如String str=&quot;8 10 15 5 2 7&quot;;    2,5,7,8,10,15  使用 TreeSet完成。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//练习3.定义一个Person数组，将Person数组中的重复对象剔除 </span></span><br></pre></td></tr></table></figure><h1 id="第7章-Collections类-集合工具类"><a href="#第7章-Collections类-集合工具类" class="headerlink" title="第7章  Collections类 - 集合工具类"></a>第7章  Collections类 - 集合工具类</h1><h2 id="7-1-Collections常用功能"><a href="#7-1-Collections常用功能" class="headerlink" title="7.1 Collections常用功能"></a>7.1 Collections常用功能</h2><ul><li><p><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。</p><p>常用方法如下：</p></li><li><p><code>public static void shuffle(List&lt;?&gt; list) </code>:打乱集合顺序。</p></li><li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p></li><li><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</p></li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">   </span><br><span class="line">        list.add(<span class="number">100</span>);</span><br><span class="line">        list.add(<span class="number">300</span>);</span><br><span class="line">        list.add(<span class="number">200</span>);</span><br><span class="line">        list.add(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">//排序方法 </span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">[<span class="number">50</span>,<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br></pre></td></tr></table></figure><p>我们的集合按照默认的自然顺序进行了排列，如果想要指定顺序那该怎么办呢？</p><h2 id="7-2-Comparator比较器"><a href="#7-2-Comparator比较器" class="headerlink" title="7.2 Comparator比较器"></a>7.2 Comparator比较器</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p><p>Student 类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">    <span class="comment">//get/set</span></span><br><span class="line"> <span class="comment">//toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建四个学生对象 存储到集合中</span></span><br><span class="line">        ArrayList&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;rose&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">20</span>));</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge()-o2.getAge();<span class="comment">//以学生的年龄升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;jack&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;rose&#x27;</span>, age=<span class="number">18</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;abc&#x27;</span>, age=<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-可变参数"><a href="#7-3-可变参数" class="headerlink" title="7.3 可变参数"></a>7.3 可变参数</h2><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化.</p><p><strong>格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure><p><strong>代码演示:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeArgs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>... arr)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : arr) &#123;</span><br><span class="line">         sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>​1.一个方法只能有一个可变参数</p><p>​2.如果方法中有多个参数，可变参数要放到最后。</p><p><strong>应用场景: Collections</strong></p><p>​在Collections中也提供了添加一些元素方法：</p><p>​<code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</p><p><strong>代码演示:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionsDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">      <span class="comment">//原来写法</span></span><br><span class="line">      <span class="comment">//list.add(12);</span></span><br><span class="line">      <span class="comment">//list.add(14);</span></span><br><span class="line">      <span class="comment">//list.add(15);</span></span><br><span class="line">      <span class="comment">//list.add(1000);</span></span><br><span class="line">      <span class="comment">//采用工具类 完成 往集合中添加元素  </span></span><br><span class="line">      Collections.addAll(list, <span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>，<span class="number">2</span>);</span><br><span class="line">      System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第8章-集合综合案例"><a href="#第8章-集合综合案例" class="headerlink" title="第8章 集合综合案例"></a>第8章 集合综合案例</h1><h2 id="8-1-案例介绍"><a href="#8-1-案例介绍" class="headerlink" title="8.1 案例介绍"></a>8.1 案例介绍</h2><p>按照斗地主的规则，完成<strong>洗牌发牌</strong>的动作。<br>具体规则：</p><p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p><h2 id="8-2-案例分析"><a href="#8-2-案例分析" class="headerlink" title="8.2 案例分析"></a>8.2 案例分析</h2><ul><li><p>准备牌：</p><p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</p></li><li><p>发牌</p><p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p></li><li><p>看牌</p><p>直接打印每个集合。</p></li></ul><h2 id="8-3-代码实现"><a href="#8-3-代码实现" class="headerlink" title="8.3 代码实现"></a>8.3 代码实现</h2><ol><li>Poker.java</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Poker</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Poker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个ArrayList用于存放一副牌</span></span><br><span class="line">        ArrayList&lt;Poker&gt; pokers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        pokers.add(<span class="keyword">new</span> <span class="title class_">Poker</span>(<span class="string">&quot;大王&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">        pokers.add(<span class="keyword">new</span> <span class="title class_">Poker</span>(<span class="string">&quot;小王&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        String[] colors = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;♠&quot;</span>, <span class="string">&quot;♥&quot;</span>, <span class="string">&quot;♣&quot;</span>, <span class="string">&quot;♦&quot;</span>&#125;;</span><br><span class="line">        String[] numbers = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;2&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;K&quot;</span>, <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="string">&quot;10&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 组合牌, 嵌套循环的流程:外循环一次,内循环所有次</span></span><br><span class="line">        <span class="comment">// 2.使用嵌套循环生成一副牌</span></span><br><span class="line">        <span class="keyword">for</span> (String n : numbers) &#123;</span><br><span class="line">            <span class="comment">// &quot;2&quot;, &quot;A&quot;</span></span><br><span class="line">            <span class="keyword">for</span> (String c : colors) &#123;</span><br><span class="line">                <span class="comment">// &quot;♠&quot;, &quot;♥&quot;, &quot;♣&quot;, &quot;♦&quot;</span></span><br><span class="line">                <span class="type">Poker</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poker</span>(c, n);</span><br><span class="line">                <span class="comment">// 3.将54张牌放到集合</span></span><br><span class="line">                pokers.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印</span></span><br><span class="line"><span class="comment">//        System.out.println(pokers);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 洗牌: Collections,集合工具类</span></span><br><span class="line">        <span class="comment">// static void shuffle​(List&lt;?&gt; list) 将集合中元素的顺序打乱</span></span><br><span class="line">        Collections.shuffle(pokers);</span><br><span class="line">        System.out.println(<span class="string">&quot;洗牌后:&quot;</span> + pokers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发牌</span></span><br><span class="line">        <span class="comment">// 1.创建3个玩家集合,创建底牌集合</span></span><br><span class="line">        ArrayList&lt;Poker&gt; player01 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Poker&gt; player02 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Poker&gt; player03 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Poker&gt; diPai = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.遍历牌的集合</span></span><br><span class="line">        <span class="comment">//            0     1      2     3     4     5      6     7     8      9     10 ...51    52     53</span></span><br><span class="line">        <span class="comment">// pokers = [♦5], [♣4], [♦8], [♣A], [♣7], [♦2], [♠6], [♣J], [♥A], [♥7], [♥6], [♣5], [♦7], [♥10]</span></span><br><span class="line">        <span class="comment">// 玩家1:   索引0,3,6       索引 % 3 == 0</span></span><br><span class="line">        <span class="comment">// 玩家2:   索引1,4,7       索引 % 3 == 1</span></span><br><span class="line">        <span class="comment">// 玩家3:   索引2,5,8       索引 % 3 == 2</span></span><br><span class="line">        <span class="comment">// 3.根据索引将牌发给不同的玩家</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pokers.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// i表示索引,poker就是i索引对应的poker</span></span><br><span class="line">            <span class="type">Poker</span> <span class="variable">poker</span> <span class="operator">=</span> pokers.get(i);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">51</span>) &#123; <span class="comment">// 最后3张给底牌</span></span><br><span class="line">                diPai.add(poker);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123; <span class="comment">// 玩家1</span></span><br><span class="line">                player01.add(poker);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) &#123; <span class="comment">// 玩家2</span></span><br><span class="line">                player02.add(poker);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">2</span>) &#123; <span class="comment">// 玩家3</span></span><br><span class="line">                player03.add(poker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 看牌</span></span><br><span class="line">        System.out.println(<span class="string">&quot;玩家1: &quot;</span> + player01);</span><br><span class="line">        System.out.println(<span class="string">&quot;玩家2: &quot;</span> + player02);</span><br><span class="line">        System.out.println(<span class="string">&quot;玩家3: &quot;</span> + player03);</span><br><span class="line">        System.out.println(<span class="string">&quot;底牌: &quot;</span> + diPai);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还要创建一副牌</span></span><br><span class="line">        <span class="comment">// 创建一个ArrayList用于存放一副牌</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> list </tag>
            
            <tag> set </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream 流常用方法</title>
      <link href="/2024/05/26/Stream%E6%B5%81%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2024/05/26/Stream%E6%B5%81%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>她·</p><p>Stream常用的流方法以及它们的详细示例：</p><h4 id="1-filter"><a href="#1-filter" class="headerlink" title="1. filter()"></a>1. <code>filter()</code></h4><p>用于过滤流中的元素，根据指定的条件保留符合条件的元素。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;String&gt; names = Arrays.asList(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Emily&quot;</span>);</span><br><span class="line">List&lt;String&gt; filteredNames = names.stream()</span><br><span class="line">                                 .filter(name -&gt; name.startsWith(<span class="string">&quot;A&quot;</span>))</span><br><span class="line">                                 .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 结果为 [&quot;Alice&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="2-map"><a href="#2-map" class="headerlink" title="2. map()"></a>2. <code>map()</code></h4><p>将流中的元素通过指定的函数映射为另一种类型。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;String&gt; names = Arrays.asList(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Emily&quot;</span>);</span><br><span class="line">List&lt;Integer&gt; nameLengths = names.stream()</span><br><span class="line">                                .map(String::length)</span><br><span class="line">                                .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 结果为 [4, 5, 3, 5]</span></span><br></pre></td></tr></table></figure><h4 id="3-flatMap"><a href="#3-flatMap" class="headerlink" title="3. flatMap()"></a>3. <code>flatMap()</code></h4><p>将流中的每个元素转换为另一个流，并将所有流连接成一个流。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;List&lt;Integer&gt;&gt; numbers = Arrays.asList(</span><br><span class="line">    Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">    Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">    Arrays.asList(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">);</span><br><span class="line">List&lt;Integer&gt; flattenedList = numbers.stream()</span><br><span class="line">                                    .flatMap(List::stream)</span><br><span class="line">                                    .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 结果为 [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><h4 id="4-sorted"><a href="#4-sorted" class="headerlink" title="4. sorted()"></a>4. <code>sorted()</code></h4><p>对流中的元素进行排序。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; sortedNumbers = numbers.stream()</span><br><span class="line">                                    .sorted()</span><br><span class="line">                                    .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 结果为 [1, 1, 2, 3, 4, 5, 5, 6, 9]</span></span><br></pre></td></tr></table></figure><h4 id="5-distinct"><a href="#5-distinct" class="headerlink" title="5. distinct()"></a>5. <code>distinct()</code></h4><p>去除流中的重复元素。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; distinctNumbers = numbers.stream()</span><br><span class="line">                                       .distinct()</span><br><span class="line">                                       .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 结果为 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h4 id="6-limit"><a href="#6-limit" class="headerlink" title="6. limit()"></a>6. <code>limit()</code></h4><p>限制流中元素的数量。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">List&lt;Integer&gt; limitedNumbers = numbers.stream()</span><br><span class="line">                                     .limit(<span class="number">5</span>)</span><br><span class="line">                                     .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 结果为 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h4 id="7-skip"><a href="#7-skip" class="headerlink" title="7. skip()"></a>7. <code>skip()</code></h4><p>跳过流中的前 N 个元素。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">List&lt;Integer&gt; skippedNumbers = numbers.stream()</span><br><span class="line">                                      .skip(<span class="number">5</span>)</span><br><span class="line">                                      .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 结果为 [6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure><h4 id="8-forEach"><a href="#8-forEach" class="headerlink" title="8. forEach()"></a>8. <code>forEach()</code></h4><p>对流中的每个元素执行指定的操作。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;String&gt; names = Arrays.asList(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Emily&quot;</span>);</span><br><span class="line">names.stream()</span><br><span class="line">     .forEach(System.out::println);</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// John</span></span><br><span class="line"><span class="comment">// Alice</span></span><br><span class="line"><span class="comment">// Bob</span></span><br><span class="line"><span class="comment">// Emily</span></span><br></pre></td></tr></table></figure><p>这些是流中的一些常用方法及其详细示例。您可以根据具体的需求使用这些方法来操作流中的元素。</p><h4 id="9-anyMatch"><a href="#9-anyMatch" class="headerlink" title="9. anyMatch()"></a>9. <code>anyMatch()</code></h4><p>检查流中是否至少有一个元素满足给定的条件。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">                          .anyMatch(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 结果为 true，因为存在偶数元素</span></span><br></pre></td></tr></table></figure><h4 id="10-allMatch"><a href="#10-allMatch" class="headerlink" title="10. allMatch()"></a>10. <code>allMatch()</code></h4><p>检查流中的所有元素是否都满足给定的条件。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;Integer&gt; numbers = Arrays.asList(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">allMatch</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">                          .allMatch(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 结果为 true，因为所有元素都是偶数</span></span><br></pre></td></tr></table></figure><h4 id="11-noneMatch"><a href="#11-noneMatch" class="headerlink" title="11. noneMatch()"></a>11. <code>noneMatch()</code></h4><p>检查流中是否没有任何元素满足给定的条件。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">noneMatch</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">                           .noneMatch(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 结果为 true，因为没有任何元素是偶数</span></span><br></pre></td></tr></table></figure><h4 id="12-reduce"><a href="#12-reduce" class="headerlink" title="12. reduce()"></a>12. <code>reduce()</code></h4><p>将流中的元素进行归约操作，得到一个最终的结果。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; sum = numbers.stream()</span><br><span class="line">                              .reduce((x, y) -&gt; x + y);</span><br><span class="line"><span class="comment">// 结果为 Optional[15]</span></span><br></pre></td></tr></table></figure><h4 id="13-collect"><a href="#13-collect" class="headerlink" title="13. collect()"></a>13. <code>collect()</code></h4><p>将流中的元素收集到一个集合中，如列表、集合或映射。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;String&gt; names = Arrays.asList(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Emily&quot;</span>);</span><br><span class="line">Set&lt;String&gt; nameSet = names.stream()</span><br><span class="line">                          .collect(Collectors.toSet());</span><br><span class="line"><span class="comment">// 结果为 &#123;&quot;John&quot;, &quot;Alice&quot;, &quot;Bob&quot;, &quot;Emily&quot;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="14-findFirst"><a href="#14-findFirst" class="headerlink" title="14. findFirst()"></a>14. <code>findFirst()</code></h4><p>获取流中的第一个元素（如果存在）。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; firstNumber = numbers.stream()</span><br><span class="line">                                      .findFirst();</span><br><span class="line"><span class="comment">// 结果为 Optional[1]</span></span><br></pre></td></tr></table></figure><h4 id="15-findAny"><a href="#15-findAny" class="headerlink" title="15. findAny()"></a>15. <code>findAny()</code></h4><p>获取流中的任意一个元素（如果存在），适用于并行流。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; anyNumber = numbers.stream()</span><br><span class="line">                                    .findAny();</span><br><span class="line"><span class="comment">// 结果可能是 Optional[1]、Optional[2] 等</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collectors API</title>
      <link href="/2024/05/26/Collectors/"/>
      <url>/2024/05/26/Collectors/</url>
      
        <content type="html"><![CDATA[<p><strong>Collectors</strong> API 是 Java 中用于收集（collecting）流元素到各种数据结构的工具类。它提供了丰富的静态方法来支持将流元素收集到列表、集合、映射等不同类型的数据结构中。这些方法可以与流的 <code>collect</code> 方法一起使用，用于生成最终的结果。</p><p>下面是一些常用的 <code>Collectors</code> API 的用法示例：</p><h3 id="1-toList"><a href="#1-toList" class="headerlink" title="1. toList()"></a>1. <code>toList()</code></h3><p>将流中的元素收集到一个列表中。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;String&gt; names = Stream.of(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Emily&quot;</span>)</span><br><span class="line">                           .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 结果为 [&quot;John&quot;, &quot;Alice&quot;, &quot;Bob&quot;, &quot;Emily&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="2-toSet"><a href="#2-toSet" class="headerlink" title="2. toSet()"></a>2. <code>toSet()</code></h3><p>将流中的元素收集到一个集合中。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaSet&lt;String&gt; uniqueNames = Stream.of(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">                                .collect(Collectors.toSet());</span><br><span class="line"><span class="comment">// 结果为 &#123;&quot;John&quot;, &quot;Alice&quot;, &quot;Bob&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-toMap"><a href="#3-toMap" class="headerlink" title="3. toMap()"></a>3. <code>toMap()</code></h3><p>将流中的元素收集到一个映射中，可以指定键和值的映射关系。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaMap&lt;String, Integer&gt; nameLengthMap = Stream.of(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Emily&quot;</span>)</span><br><span class="line">                                           .collect(Collectors.toMap(Function.identity(), String::length));</span><br><span class="line"><span class="comment">// 结果为 &#123;&quot;John&quot;=4, &quot;Alice&quot;=5, &quot;Bob&quot;=3, &quot;Emily&quot;=5&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-joining"><a href="#4-joining" class="headerlink" title="4. joining()"></a>4. <code>joining()</code></h3><p>将流中的元素连接成一个字符串。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">javaString</span> <span class="variable">allNames</span> <span class="operator">=</span> Stream.of(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Emily&quot;</span>)</span><br><span class="line">                        .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line"><span class="comment">// 结果为 &quot;John, Alice, Bob, Emily&quot;</span></span><br></pre></td></tr></table></figure><h3 id="5-groupingBy"><a href="#5-groupingBy" class="headerlink" title="5. groupingBy()"></a>5. <code>groupingBy()</code></h3><p>根据指定的分类函数对流中的元素进行分组。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaMap&lt;Integer, List&lt;String&gt;&gt; namesByLength = Stream.of(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Emily&quot;</span>)</span><br><span class="line">                                                 .collect(Collectors.groupingBy(String::length));</span><br><span class="line"><span class="comment">// 结果为 &#123;3=[&quot;Bob&quot;], 4=[&quot;John&quot;], 5=[&quot;Alice&quot;, &quot;Emily&quot;]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="6-partitioningBy"><a href="#6-partitioningBy" class="headerlink" title="6. partitioningBy()"></a>6. <code>partitioningBy()</code></h3><p>根据给定的条件将流中的元素分成两组。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaMap&lt;Boolean, List&lt;String&gt;&gt; partitionedNames = Stream.of(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Emily&quot;</span>)</span><br><span class="line">                                         .collect(Collectors.partitioningBy(s -&gt; s.length() &gt; <span class="number">3</span>));</span><br><span class="line"><span class="comment">// 结果为 &#123;false=[&quot;Bob&quot;], true=[&quot;John&quot;, &quot;Alice&quot;, &quot;Emily&quot;]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="7-counting"><a href="#7-counting" class="headerlink" title="7. counting()"></a>7. <code>counting()</code></h3><p>计算流中元素的个数。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">javalong</span> <span class="variable">count</span> <span class="operator">=</span> Stream.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>)</span><br><span class="line">                   .collect(Collectors.counting());</span><br><span class="line"><span class="comment">// 结果为 4</span></span><br></pre></td></tr></table></figure><h3 id="8-averagingInt"><a href="#8-averagingInt" class="headerlink" title="8. averagingInt()"></a>8. <code>averagingInt()</code></h3><p>计算流中整数类型元素的平均值。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">javadouble</span> <span class="variable">averageLength</span> <span class="operator">=</span> Stream.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>)</span><br><span class="line">                             .collect(Collectors.averagingInt(String::length));</span><br><span class="line"><span class="comment">// 结果为 5.25 (所有单词长度之和除以单词个数)</span></span><br></pre></td></tr></table></figure><h3 id="9-summarizingInt"><a href="#9-summarizingInt" class="headerlink" title="9. summarizingInt()"></a>9. <code>summarizingInt()</code></h3><p>对流中的整数类型元素进行汇总统计，包括计数、总和、平均值、最大值和最小值。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">javaIntSummaryStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span> Stream.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>)</span><br><span class="line">                                       .collect(Collectors.summarizingInt(String::length));</span><br><span class="line"><span class="comment">// 结果为 IntSummaryStatistics&#123;count=4, sum=21, min=5, average=5.250000, max=6&#125;</span></span><br></pre></td></tr></table></figure><h3 id="10-joining"><a href="#10-joining" class="headerlink" title="10. joining()"></a>10. <code>joining()</code></h3><p>将流中的元素连接成一个字符串，可以指定连接符、前缀和后缀。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">javaString</span> <span class="variable">concatenated</span> <span class="operator">=</span> Stream.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>)</span><br><span class="line">                            .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>));</span><br><span class="line"><span class="comment">// 结果为 &quot;[apple, banana, orange, grape]&quot;</span></span><br></pre></td></tr></table></figure><h3 id="11-mapping"><a href="#11-mapping" class="headerlink" title="11. mapping()"></a>11. <code>mapping()</code></h3><p>对流中的元素进行转换，并对转换结果进行收集。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaList&lt;String&gt; upperCaseNames = Stream.of(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Emily&quot;</span>)</span><br><span class="line">                                   .collect(Collectors.mapping(String::toUpperCase, Collectors.toList()));</span><br><span class="line"><span class="comment">// 结果为 [&quot;JOHN&quot;, &quot;ALICE&quot;, &quot;BOB&quot;, &quot;EMILY&quot;]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> collectors </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基本类型和包装类</title>
      <link href="/2024/05/24/javaSE1/"/>
      <url>/2024/05/24/javaSE1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1.基本数据类型"></a>1.基本数据类型</h3><p>数值类型<br>整型<br>byte 1字节 2^7-1<br>short 2字节 2^15-1<br>int 4字节 2^31-1<br>long 8字节 2^63-1 需要在值后面指定L<br>浮点型<br>float 4字节 单精度浮点型，最大7位精度 需要在值后面指定F<br>double 8字节 双精度浮点，最大16位精度<br>布尔类型<br>boolean 只有true和false<br>字符类型<br>char 0~65535 赋值用单引号 ‘A</p><p>原文链接：<a href="https://blog.csdn.net/baichrn/article/details/119025540">https://blog.csdn.net/baichrn/article/details/119025540</a></p><h3 id="2-堆、栈常量池"><a href="#2-堆、栈常量池" class="headerlink" title="2.堆、栈常量池"></a>2.堆、栈常量池</h3><p> 整型常量池 -128~127</p><h3 id="3-包装类"><a href="#3-包装类" class="headerlink" title="3.包装类"></a>3.包装类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;i1=i2   &quot;</span> + (i1 == i2));</span><br><span class="line">  System.out.println(<span class="string">&quot;i1=i2+i3   &quot;</span> + (i1 == i2 + i3));</span><br><span class="line">  System.out.println(<span class="string">&quot;i1=i4   &quot;</span> + (i1 == i4));</span><br><span class="line">  System.out.println(<span class="string">&quot;i4=i5   &quot;</span> + (i4 == i5));</span><br><span class="line">  System.out.println(<span class="string">&quot;i4=i5+i6   &quot;</span> + (i4 == i5 + i6));</span><br><span class="line">  System.out.println(<span class="string">&quot;40=i5+i6   &quot;</span> + (<span class="number">40</span> == i5 + i6));</span><br><span class="line"></span><br><span class="line">----结果----</span><br><span class="line">(<span class="number">1</span>)i1=i2   <span class="title function_">true</span></span><br><span class="line"><span class="params">(<span class="number">2</span>)</span>i1=i2+i3   <span class="title function_">true</span></span><br><span class="line"><span class="params">(<span class="number">3</span>)</span>i1=i4   <span class="title function_">false</span></span><br><span class="line"><span class="params">(<span class="number">4</span>)</span>i4=i5   <span class="title function_">false</span></span><br><span class="line"><span class="params">(<span class="number">5</span>)</span>i4=i5+i6   <span class="title function_">true</span></span><br><span class="line"><span class="params">(<span class="number">6</span>)</span><span class="number">40</span>=i5+i6   <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这段代码涉及了自动装箱和拆箱的概念，以及 Java 中 Integer 类型的缓存范围。</p><ol><li><code>Integer i1 = 40;</code> 和 <code>Integer i2 = 40;</code>：在 Java 中，对于数值在 <strong>-128 到 127</strong> 之间的 Integer 对象，会进行缓存，因此 <code>i1</code> 和 <code>i2</code> 实际上是引用了同一个 Integer 对象。所以 <code>(i1 == i2)</code> 为 true。</li><li><code>(i1 == i2 + i3)</code>：<code>i2 + i3</code> 会进行自动拆箱，得到的是一个 int 类型的值，即 40。因此 <code>(i1 == 40)</code>，由于 i1 也是一个 Integer 对象，所以会进行自动装箱，然后比较对象引用，结果也是 true。</li><li><code>(i1 == i4)</code>：<code>i4</code> 是通过 <code>new Integer(40)</code> 显式创建的一个新的 Integer 对象，而 <code>i1</code> 是从缓存中取得的对象，它们的引用不同，因此 <code>(i1 == i4)</code> 为 false。</li><li><code>(i4 == i5)</code>：同样，<code>i4</code> 和 <code>i5</code> 是分别通过 <code>new Integer(40)</code> 创建的两个不同的对象，它们的引用也不同，因此 <code>(i4 == i5)</code> 为 false。</li><li>自动拆箱</li><li><code>(40 == i5 + i6)</code>：同样，<code>i5 + i6</code> 会进行自动拆箱，得到的是一个 int 类型的值，即 40，然后 40 会自动装箱成一个 Integer 对象，而 <code>i5 + i6</code> 所得到的对象与 40 的引用是相同的，因此 <code>(40 == i5 + i6)</code> 为 true。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.igeek.javase.ch07.numbers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> fengqq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 包装类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/24  11:24</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 基本类型  对应的包装类</span></span><br><span class="line"><span class="comment"> * byte     Byte</span></span><br><span class="line"><span class="comment"> * short    Short</span></span><br><span class="line"><span class="comment"> * int      Integer</span></span><br><span class="line"><span class="comment"> * long     Long</span></span><br><span class="line"><span class="comment"> * float    Float</span></span><br><span class="line"><span class="comment"> * double   Double</span></span><br><span class="line"><span class="comment"> * char     Character</span></span><br><span class="line"><span class="comment"> * boolean  Boolean</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.（位于java.lang包中）</span></span><br><span class="line"><span class="comment"> * 2. 整型常量池 -128~127</span></span><br><span class="line"><span class="comment"> * 3. 自动装箱/自动拆箱  jdk5，不要频繁的发生拆装箱</span></span><br><span class="line"><span class="comment"> *      自动装箱：将基本数组类型的值 自动转换为 包装类型         int--&gt;Integer  等价于 new Integer(int i)</span></span><br><span class="line"><span class="comment"> *      自动拆箱: 将包装类型 自动转换为 对应的 基本数组类型的值   Integer--&gt;int  等价于 int a = intValue()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 基本数据类型和字符串进行转换</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5.static String toBinaryString(int i) 在基地 2无符号整数返回整数参数的字符串表示形式。</span></span><br><span class="line"><span class="comment"> *  static String toHexString(int i)     在基地 16无符号整数返回整数参数的字符串表示形式。</span></span><br><span class="line"><span class="comment"> *  static String toOctalString(int i)   在基地 8无符号整数返回整数参数的字符串表示形式。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//自动装箱：将基本数组类型的值 自动转换为 包装类型</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">128</span>;<span class="comment">//隐式装箱 new Integer(128)</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">128</span>;<span class="comment">//隐式装箱 new Integer(128)</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);<span class="comment">//手动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);<span class="comment">//手动装箱</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;i1==i2 = &quot;</span> + (i1 == i2));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i3==i4 = &quot;</span> + (i3 == i4));<span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i5==i6 = &quot;</span> + (i5 == i6));<span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;i1==i5 = &quot;</span> + (i1 == i5));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//自动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i5;</span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参与运算时 会自动拆箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        n++;<span class="comment">//先自动拆箱 --&gt; ++ --&gt; 最后自动装箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        n+=b;<span class="comment">//Integer n = n+b;  //先自动拆箱 --&gt; n+b --&gt; 最后自动装箱</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> n+<span class="number">10</span>;<span class="comment">//拆箱</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------自动拆箱---------------&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">        System.out.println(x1 == x2); <span class="comment">//true  Integer == int     将Integer自动拆箱为int 用int==int比较</span></span><br><span class="line">        System.out.println(x1 == x3); <span class="comment">//false Integer == Integer 用地址比较</span></span><br><span class="line">        System.out.println(x1.equals(x3)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(x2 == x3); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------基本数据类型和字符串进行转换-----------&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//int --&gt; String</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> m+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(m);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> Integer.toString(m);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String --&gt; int</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        <span class="comment">//如果字符串中包含非法字符 则转换为整数类型时 会产生异常 NumberFormatException</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.parseInt(str);<span class="comment">//默认使用十进制来解析字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.parseInt(str2,<span class="number">16</span>);<span class="comment">//使用16进制来解析字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n2 = &quot;</span> + n2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String --&gt; Integer</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">t</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String --&gt; double</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">v</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;6.12&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基本数据类型 </tag>
            
            <tag> 堆、栈和常量池 </tag>
            
            <tag> 包装类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String，StringBuilder，StringBuffer</title>
      <link href="/2024/05/24/String,StringBulider,StringBuffer/"/>
      <url>/2024/05/24/String,StringBulider,StringBuffer/</url>
      
        <content type="html"><![CDATA[<h3 id="1-String类"><a href="#1-String类" class="headerlink" title="1.String类"></a>1.String类</h3><p> 1.不能被继承 final class String {} 实现接口CharSequence(字符序列)</p><p> 2.字符串本质是一个字符数组，索引从0开始</p><p> 3.字符串是常量，一旦被赋值，就不能被改变,String是不可变字符序列</p><p> 4.字符串常量池：jdk对String优化。将在堆内存中开辟了一段空间(常量池),所有字符串的字面值 都维护在池中</p><p> String s &#x3D; “abc”;     当定义一个变量s时，jdk首先会在池中寻找有没有”abc”,如果没有，则在池中开辟新空间值为”abc” 将新空间的地址赋给变量s</p><p>   String s2 &#x3D; “abc”;    当定义一个变量s2时，jdk首先会在池中寻找有没有”abc”,如果有，则将池中”abc“的地址 赋给变量s2</p><p>5.对字符串进行API方法处理后(substring,replace,trim…)返回的是新字符串，原始字符串不改变</p><p>String常用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//不可变特性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        s = <span class="string">&quot;hello&quot;</span>;<span class="comment">//没有改变原始对象&quot;abc&quot;的内容，只是将新对象&quot;hello&quot;的地址指向变量s</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//常量池</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1==s2 :&quot;</span>+(s1==s2));<span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s3==s4 :&quot;</span>+(s3==s4));<span class="comment">//false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s1==s4 :&quot;</span>+(s1==s4));<span class="comment">//false</span></span><br><span class="line">        <span class="comment">// 引用类型 == 比较的是地址  使用equals方法比较的内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s3.equals(s4) = &quot;</span> + s3.equals(s4));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------常用方法---------------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot; Kworld 1#233#3DHDJDSHH#JhbKSSD &quot;</span>;</span><br><span class="line">        <span class="comment">//1.求字符串的长度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;str.length() = &quot;</span> + str.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.求 K 在字符串中第一次出现的位置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;str.indexOf(&#x27;K&#x27;) = &quot;</span> + str.indexOf(<span class="string">&#x27;K&#x27;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;str.indexOf(\&quot;K\&quot;) = &quot;</span> + str.indexOf(<span class="string">&quot;K&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.求 K 在字符串中最后一次出现的位置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;str.lastIndexOf(\&quot;K\&quot;) = &quot;</span> + str.lastIndexOf(<span class="string">&quot;K&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.取出 子串world substring(start,end) 截取[start,end)区间段的子串2</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sonStr</span> <span class="operator">=</span> str.substring(<span class="number">2</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;截取后的子串 = &quot;</span> + sonStr);</span><br><span class="line">        System.out.println(<span class="string">&quot;原始字符串 = &quot;</span> + str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.获取 字符串中 第5个位置的字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot;str.charAt(4) = &quot;</span> + str.charAt(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.去掉字符串的首尾空格</span></span><br><span class="line">        System.out.println(<span class="string">&quot;str.length() = &quot;</span> + str.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;str.trim().length() = &quot;</span> + str.trim().length());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.将字符串中所有字母 变成 大写字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot;str.toUpperCase() = &quot;</span> + str.toUpperCase());</span><br><span class="line">        <span class="comment">//8.将字符串中所有字母 变成 小写字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot;str.toLowerCase() = &quot;</span> + str.toLowerCase());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//9.将明文密码变成密文    \\d代表任意一个数字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">md5Password</span> <span class="operator">=</span> password.replaceAll(<span class="string">&quot;\\d&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;md5Password = &quot;</span> + md5Password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将字符串中# 全部变成$</span></span><br><span class="line">        System.out.println(<span class="string">&quot;将字符串中# 全部变成$ = &quot;</span> + str.replace(<span class="string">&quot;#&quot;</span>, <span class="string">&quot;$&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//10.将一个字符串按照 # 进行分割为 字符串数组</span></span><br><span class="line">        String[] srr = str.split(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Arrays.toString(srr) = &quot;</span> + Arrays.toString(srr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//11.判断文件名是否是java文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;demo.java&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;判断文件名是否是java文件 = &quot;</span> + fileName.endsWith(<span class="string">&quot;.java&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//12.判断字符串中是否包含 &quot;world&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;判断字符串中是否包含(\&quot;world\&quot;) = &quot;</span> + str.contains(<span class="string">&quot;world&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//13.比较两个字符串内容是否相同 区别大小写</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;HeLLo&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a.equals(b) = &quot;</span> + a.equals(b));</span><br><span class="line">        <span class="comment">//14.比较两个字符串内容是否相同 不区别大小写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a.equalsIgnoreCase(b) = &quot;</span> + a.equalsIgnoreCase(b));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">        <span class="comment">//15.将字符串 转换为 字符数组</span></span><br><span class="line">        <span class="type">char</span>[] crr = x.toCharArray();</span><br><span class="line">        System.out.println(<span class="string">&quot;Arrays.toString(crr) = &quot;</span> + Arrays.toString(crr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//16.将字符数组 转换为 字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(crr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照指定的字符集 进行 编码和解码</span></span><br><span class="line">        <span class="comment">//UTF:一个中文占用3个字节</span></span><br><span class="line">        <span class="comment">//GBK:一个中文占用2个字节</span></span><br><span class="line">        <span class="comment">//如何处理乱码：保证编码和解码使用的字符集是一致的</span></span><br><span class="line">        <span class="comment">//17.将字符串 转换为 字节数组 ==&gt; 解码</span></span><br><span class="line">        <span class="type">byte</span>[] brr1 = x.getBytes(); <span class="comment">//使用平台默认的字符集(UTF-8)进行解码  [-28, -67, -96, -27, -91, -67]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Arrays.toString(brr1) = &quot;</span> + Arrays.toString(brr1));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] brr2 = x.getBytes(<span class="string">&quot;GBK&quot;</span>);<span class="comment">//根据指定的字符集进行解码 [-60, -29, -70, -61]</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Arrays.toString(brr2) = &quot;</span> + Arrays.toString(brr2));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (UnsupportedEncodingException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;系统不支持所写字符集！！！解码失败！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = &#123;-<span class="number">60</span>, -<span class="number">29</span>, -<span class="number">70</span>, -<span class="number">61</span>&#125;;<span class="comment">//GBK格式得到的</span></span><br><span class="line">        <span class="comment">//18.将字节数组 转换为 字符串 ==&gt; 编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes); <span class="comment">//使用平台默认的字符集(UTF-8)进行编码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;s6 = &quot;</span> + s6);<span class="comment">//乱码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;s7 = &quot;</span> + s7); <span class="comment">// 不乱码</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (UnsupportedEncodingException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;系统不支持所写字符集！！！编码失败！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-StringBuffer与StringBuilder"><a href="#2-StringBuffer与StringBuilder" class="headerlink" title="2.StringBuffer与StringBuilder"></a>2.StringBuffer与StringBuilder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBufferDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sbf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(); <span class="comment">//&quot;&quot;</span></span><br><span class="line">        <span class="comment">//末尾追加“abc”</span></span><br><span class="line">        sbf.append(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sbf = &quot;</span> + sbf);<span class="comment">//&quot;abc&#x27;</span></span><br><span class="line">        <span class="comment">//末尾追加“def”</span></span><br><span class="line">        sbf.append(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sbf = &quot;</span> + sbf);<span class="comment">//&quot;abcdef&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//大量api方法返回值都是this 通常写成链式编程</span></span><br><span class="line">        sbf.append(<span class="string">&quot;h&quot;</span>).append(<span class="string">&quot;q&quot;</span>).append(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sbf = &quot;</span> + sbf);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        appendForString();</span><br><span class="line">        appendForStringBuffer();</span><br><span class="line">        appendForStringBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试String拼接操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">appendForString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            result+=i; <span class="comment">//每次拼接会产生一个新对象  10000个对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;测试String拼接操作的执行时间:&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试StringBuffer拼接操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">appendForStringBuffer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            result.append(i); <span class="comment">//每次拼接返回是原始对象  1个对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;测试StringBuffer拼接操作的执行时间:&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试StringBuilder拼接操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">appendForStringBuilder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            result.append(i); <span class="comment">//每次拼接返回是原始对象  1个对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;测试StringBuilder拼接操作的执行时间:&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-面试题：String-StringBuffer-StringBuilder-区别"><a href="#3-面试题：String-StringBuffer-StringBuilder-区别" class="headerlink" title="3. 面试题：String StringBuffer StringBuilder 区别"></a>3. 面试题：String StringBuffer StringBuilder 区别</h3><h4 id="String"><a href="#String" class="headerlink" title="String:"></a>String:</h4><pre><code> 1. 不可变字符串  2. 线程安全  因为不可变final char[] value,所以 每个线程 对字符串进行操作后返回的是一个新字符串</code></pre><p>​  3. 执行拼接等，效率低，大量浪费有限的内存空间</p><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer:"></a>StringBuffer:</h4><p>​    1. 可变字符串  对字符串进行操作后返回的是原始对象</p><p>​    2. 多线程并发访问下，线程安全</p><p>​    3. API方法中 添加 synchronized关键字(悲观锁)</p><p>​    4. 效率低</p><p>​    5. 使用场景：大量拼接且有竞争的情况优先考虑StringBuffer</p><h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder:"></a>StringBuilder:</h4><p>​    1. 可变字符串  对字符串进行操作后返回的是原始对象</p><p>​    2. 多线程并发访问下，线程不安全，对于同一个共享变量 会出现竞争问题</p><p>​    3. 效率高</p><p>​    4. 使用场景：大量拼接且单线程下优先考虑StringBuilder</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> StringBuilder </tag>
            
            <tag> StringBuffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Comparable与Compartor</title>
      <link href="/2024/05/24/%E6%AF%94%E8%BE%83%E5%99%A8%E6%8E%92%E5%BA%8F/"/>
      <url>/2024/05/24/%E6%AF%94%E8%BE%83%E5%99%A8%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>总有些惊奇的际遇，</p><h4 id="1-自然排序-（Comparable）"><a href="#1-自然排序-（Comparable）" class="headerlink" title="1.自然排序 （Comparable）"></a>1.自然排序 （Comparable）</h4><ul><li>当一个类实现了<code>java.lang.Comparable</code>接口时，它就可以进行自然排序。<code>Comparable</code>接口中有一个方法<code>compareTo(T o)</code>，用于定义对象之间的比较规则。实现了该接口的类可以直接使用Java提供的排序方法（如<code>Collections.sort()</code>或<code>Arrays.sort()</code>）进行排序。</li></ul><h4 id="2-定制排序（Comparator）"><a href="#2-定制排序（Comparator）" class="headerlink" title="2.定制排序（Comparator）"></a>2.定制排序（Comparator）</h4><ul><li>定制排序通常用于对那些没有实现<code>Comparable</code>接口的类进行排序，或者当需要按照不同的规则进行排序时。</li><li>在这种情况下，可以使用<code>java.util.Comparator</code>接口。<code>Comparator</code>接口有一个<code>compare(T o1, T o2)</code>方法，用于定义对象之间的比较规则。可以创建一个新的比较器类实现<code>Comparator</code>接口，或者使用匿名类或Lambda表达式创建一个临时的比较器。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.igeek.javase.ch06.work.test4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mpk16</span></span><br><span class="line"><span class="comment"> * 6.新闻类：标题，内容，时间   三个属性。 有10条新闻，按照时间的降序排列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果希望当前类的对象 具备 比较性：需要实现接口Comparable&lt;T&gt; 泛型T： 需要比较的对象的类型</span></span><br><span class="line"><span class="comment"> * 接口中 只有一个抽象方法：int compareTo(T o)</span></span><br><span class="line"><span class="comment"> * x.compareTo(y)</span></span><br><span class="line"><span class="comment"> * 返回值： 0      表示 x和y是相同的</span></span><br><span class="line"><span class="comment"> * 返回值： 大于0   表示 x&gt;y</span></span><br><span class="line"><span class="comment"> * 返回值： 小于0   表示 x&lt;y</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">News</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;News&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;<span class="comment">//标题</span></span><br><span class="line">    <span class="keyword">private</span> String content;<span class="comment">//内容</span></span><br><span class="line">    <span class="keyword">private</span> LocalDate date;<span class="comment">//时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">News</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">News</span><span class="params">(String title, String content, LocalDate date)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">        <span class="built_in">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(News o)</span> &#123;</span><br><span class="line">        <span class="comment">//根据News的date属性来进行比较  如果 返回值&gt;0表示 this对象的时间大于o对象的时间</span></span><br><span class="line">        <span class="comment">//LocalDate 间接实现了Comparable接口，通过compareTo方法可以直接比较两个date对象的大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//return this.date.compareTo(o.date); //实现升序的排序规则</span></span><br><span class="line">        <span class="keyword">return</span> o.date.compareTo(<span class="built_in">this</span>.date); <span class="comment">//实现降序的排序规则</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;News&#123;title = &quot;</span> + title + <span class="string">&quot;, content = &quot;</span> + content + <span class="string">&quot;, date = &quot;</span> + date + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.igeek.javase.ch06.work.test4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> fengqq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/24  10:04</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数组的排序</span></span><br><span class="line"><span class="comment"> * Arrays.sort(T[]);                    默认使用Comparable接口的compareTo方法来实现比较规则</span></span><br><span class="line"><span class="comment"> * Arrays.sort(T[],Comparator comp);    不使用默认的Comparable接口，指定使用Comparator接口的compare方法来实现比较规则</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 升序：this前一个元素 o后一个元素</span></span><br><span class="line"><span class="comment"> * 升序：o1前一个元素 o2后一个元素</span></span><br><span class="line"><span class="comment"> * int compareTo(T o)  this&gt;o</span></span><br><span class="line"><span class="comment"> * int compare(T o1，T o2)  o1&gt;o2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 降序:</span></span><br><span class="line"><span class="comment"> * int compareTo(T o)  o&gt;this</span></span><br><span class="line"><span class="comment"> * int compare(T o1，T o2)  o2&gt;o1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.将News对象存储到数组中</span></span><br><span class="line">        News[] news = <span class="keyword">new</span> <span class="title class_">News</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; news.length; i++) &#123;</span><br><span class="line">            news[i] = <span class="keyword">new</span> <span class="title class_">News</span>(<span class="string">&quot;爆炸性新闻&quot;</span>+i,<span class="string">&quot;天王级别&quot;</span>+i, LocalDate.of(<span class="number">2024</span>,<span class="number">05</span>,<span class="number">10</span>+i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Arrays.toString(news) = &quot;</span> + Arrays.toString(news));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.1 将数组中元素进行降序排序 冒泡排序 从大到小</span></span><br><span class="line">       <span class="comment">/* for (int i = 0; i &lt; news.length-1; i++) &#123;// 轮数</span></span><br><span class="line"><span class="comment">            for (int j = 0; j &lt; news.length-1-i; j++) &#123; // j表示的是当前比较的位置</span></span><br><span class="line"><span class="comment">                //j 和 j+1 位置的元素进行比较 一旦前者比后者小，则交互位置</span></span><br><span class="line"><span class="comment">                if(news[j].getDate().compareTo(news[j+1].getDate())&lt;0 )&#123; //if(news[j].compareTo(news[j+1])&lt;0)&#123;</span></span><br><span class="line"><span class="comment">                    News temp = null;</span></span><br><span class="line"><span class="comment">                    temp = news[j+1];</span></span><br><span class="line"><span class="comment">                    news[j+1] = news[j];</span></span><br><span class="line"><span class="comment">                    news[j] = temp;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;-----------------方式一：按照时间排序后的结果--------------------&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;Arrays.toString(news) = &quot; + Arrays.toString(news));*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.2 使用Arrays.sort方法来直接实现排序  根据compareTo方法的返回值来排序 要求 if(compareTo方法的比较结果&gt;0)&#123;x和y交互位置&#125;</span></span><br><span class="line">        <span class="comment">//如果实现升序 则 x.compareTo(y)&gt;0   x&gt;y  前者大于后者 时交互元素位置</span></span><br><span class="line">        <span class="comment">//如果实现降序 则 y.compareTo(x)&gt;0   y&gt;x  前者小于后者 时交互元素位置</span></span><br><span class="line">        <span class="comment">//总结：如果直接使用Arrays.sort(T[] arr);要求数组中元素类型T 必须实现Comparable接口重写compareTo方法 否则会产生 ClassCastException</span></span><br><span class="line">      <span class="comment">/*  Arrays.sort(news);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;-----------------方式二：按照时间排序后的结果--------------------&quot;);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;Arrays.toString(news) = &quot; + Arrays.toString(news));*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.3 使用Arrays.sort(T[] arr,Comparator comp)根据Comparator接口的compare方法来进行排序  适用于进行临时比较</span></span><br><span class="line">        Arrays.sort(news, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;News&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(News o1, News o2)</span> &#123;<span class="comment">//o1代表是前者对象  o2代表的是后者对象</span></span><br><span class="line">                <span class="keyword">return</span> o2.getDate().compareTo(o1.getDate());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------方式三：按照时间排序后的结果--------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Arrays.toString(news) = &quot;</span> + Arrays.toString(news));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> Comparable </tag>
            
            <tag> Comparator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>预热</title>
      <link href="/2024/05/23/java%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/05/23/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>闲来无事，写博客</p><h3 id="1、使用-‘-’-而不是-‘equals-’-来比较字符串值"><a href="#1、使用-‘-’-而不是-‘equals-’-来比较字符串值" class="headerlink" title="1、使用 ‘&#x3D;&#x3D;’ 而不是 ‘equals()’ 来比较字符串值"></a>1、使用 ‘&#x3D;&#x3D;’ 而不是 ‘equals()’ 来比较字符串值</h3><p> 默认情况下也就是从超类Object继承而来的equals方法与‘&#x3D;&#x3D;’是完全等价的，比较的都是对象的内存地址，但我们可以重写equals方法，使其按照我们的需求的方式进行比较，如String类重写了equals方法，使其比较的是字符的序列，而不再是内存地址。 </p><h3 id="2、接口实例化的方法"><a href="#2、接口实例化的方法" class="headerlink" title="2、接口实例化的方法"></a>2、接口实例化的方法</h3><p>在Java中，接口是不能直接实例化的，因为接口本身是抽象的，不包含具体的实现。但是，可以通过以下几种方式来实例化接口：</p><ol><li><p><strong>通过实现类实例化</strong>： 创建一个实现了该接口的类的对象，并将其赋给接口类型的引用变量。这样，该对象就可以通过接口类型的引用进行访问。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">javaIStorage</span> <span class="variable">storage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyStorageImpl</span>(); <span class="comment">// MyStorageImpl是实现了IStorage接口的类</span></span><br></pre></td></tr></table></figure></li><li><p><strong>匿名内部类</strong>： 可以通过创建一个匿名内部类来实现接口，并直接在实例化的过程中提供具体的实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">javaIStorage</span> <span class="variable">storage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IStorage</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现read方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实现write方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>Lambda表达式</strong>（仅适用于函数式接口）： 如果接口是函数式接口（只包含一个抽象方法），可以使用Lambda表达式来实例化接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">javaIStorage</span> <span class="variable">storage</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="comment">// Lambda表达式提供的具体实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>通过以上方法，可以在实际编程中灵活地实例化接口并使用其功能。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日英语09-20</title>
      <link href="/2023/09/20/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD09-20/"/>
      <url>/2023/09/20/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD09-20/</url>
      
        <content type="html"><![CDATA[<h3 id="每日英语09-20"><a href="#每日英语09-20" class="headerlink" title="每日英语09-20"></a>每日英语09-20</h3><h4 id="重点单词"><a href="#重点单词" class="headerlink" title="重点单词"></a>重点单词</h4><table><thead><tr><th>单词</th><th>类型</th><th>描述</th><th>例句</th></tr></thead><tbody><tr><td><a href="https://engoo.com/app/words/word/luxurious/zga0ELstQmCjlQAAAABf_A">luxurious</a></td><td>Adjective</td><td>expensive and of very high quality<br>价格昂贵，质量非常高</td><td>The latest Bentley is even more <strong>luxurious</strong> than the old model.<br/>最新的宾利甚至比旧车型更豪华。</td></tr><tr><td><a href="https://engoo.com/app/words/word/nanny/7970I43nQLewWymP3N8t4g">nanny</a></td><td>Noun</td><td>a person whose job involves taking care of someone’s children<br>工作涉及照顾某人孩子的人</td><td>The movie “Mary Poppins” is about a magical <strong>nanny</strong> who can fly with an umbrella.<br/>电影《玛丽·波平斯》讲述的是一个能撑伞飞翔的神奇保姆。</td></tr><tr><td><a href="https://engoo.com/app/words/word/incident/zga0ELstQmCjlQAAAAB6rg">incident</a></td><td>Noun</td><td>an event, especially one that is unpleasant or dangerous<br/>事件，尤其是不愉快或危险的事件</td><td>The report said that the plane was on autopilot when the <strong>incident</strong> occurred.<br/>报道称，事件发生时飞机处于自动驾驶状态。</td></tr><tr><td><a href="https://engoo.com/app/words/word/audit/zga0ELstQmCjlQAAAABgHw">audit</a></td><td>Noun</td><td>an official examination into an organization’s financial records; a systematic analysis or review of something<br/>对组织的财务记录进行正式检查;对某事的系统分析或审查</td><td>An external accountant was called in to perform an <strong>audit</strong>.<br/>一名外部会计师被要求进行审计。</td></tr><tr><td><a href="https://engoo.com/app/words/word/aviation/zga0ELstQmCjlQAAAAAW_w">aviation</a></td><td>Noun</td><td>the designing, making, and operating of planes<br/>飞机的设计、制造和运营</td><td>Amelia Earhart, a pioneer in <strong>aviation</strong>, was the first woman to fly solo across the Atlantic.<br/>航空先驱阿米莉亚·埃尔哈特（Amelia Earhart）是第一位独自飞越大西洋的女性。</td></tr><tr><td><a href="https://engoo.com/app/words/word/distinguish/1BA56847ShK8rJbCMx8TcA">distinguish</a></td><td>Verb</td><td>to be an identifying mark or feature of<br/>作为识别标记或特征</td><td>What <strong>distinguishes</strong> the band from others in the genre is their complex song structures.<br/>乐队与该流派其他乐队的区别在于他们复杂的歌曲结构。</td></tr></tbody></table><h4 id="Adjective-Noun-Verb是什么"><a href="#Adjective-Noun-Verb是什么" class="headerlink" title="Adjective ,Noun, Verb是什么"></a>Adjective ,Noun, Verb是什么</h4><p>是一个通用的短语结构，用来表示一个动作或状态。它由以下三个部分组成：</p><p>1.Adjective（形容词）：描述或修饰名词，通常用来提供名词的特征或性质。<br>2.Noun（名词）：通常是一个物体、概念、人或地方的名称，它是句子中的主语或宾语。<br>3.Verb（动词）：表示一个动作、状态或事件的词汇，描述了名词执行的动作。</p><p>因此，”Adjective Noun Verb” 的结构用来构建句子，其中形容词描述名词并指定动作或状态。这种结构可以用于创造各种句子，例如：</p><p>4.”Beautiful flowers bloom.”（美丽的花朵绽放。）<br>5.”Hungry children eat.”（饥饿的孩子们吃饭。）<br>6.”Tired workers rest.”（疲惫的工人休息。）</p><p>这些句子分别由形容词（beautiful、hungry、tired）、名词（flowers、children、workers）和动词（bloom、eat、rest）组成，形成了不同的意义。这种结构可以用来构建简单的句子，以传达各种情感、情况和描述。</p><h4 id="文章内容"><a href="#文章内容" class="headerlink" title="文章内容"></a>文章内容</h4><p>Qantas Named World’s Safest Airline for 2023</p><p>While things like price and <strong>flight time</strong> might be important when buying an <strong>airline</strong> ticket, there’s probably nothing more important than feeling safe when that plane starts to <strong>speed up</strong> on the runway before shooting up into the sky.</p><p>If safety is the thing you’re most worried about, AirlineRatings.com may be able to help: the website has announced its top 20 safest airlines for 2023, chosen out of 385 airlines watched by the site.</p><p>According to the website, the safest airline for 2023 is the Australian airline Qantas. Started in 1920, it’s now the world’s second-oldest airline, <strong>as well as</strong> the largest in Australia. AirlineRatings.com notes that it’s known for its experience and its safety.</p><p>Next is Air New Zealand. <strong>It’s not quite as old as Qantas</strong> — but that might be a good thing, since it also has younger <strong>aircraft</strong>, with most of its passenger <strong>jets</strong> less than 10 years old. It also runs one of the longest flights in the world: 17-and-a-half hours between New York and Auckland.</p><p>Third is Etihad Airways, the national airline of the United Arab Emirates. Just 20 years old, it’s known for its luxurious service — such as nannies for young children on long flights. And its planes are even younger than Air New Zealand’s.</p><p>Fourth and fifth are Qatar Airways and Singapore Airlines. Singapore Airlines runs the world’s longest flight — 19 hours from New York to Singapore.</p><p>AirlineRatings.com chose the safest airlines by looking at crashes over five years, serious incidents over two years, pilot training, the age of the airline’s planes, coronavirus rules, and the results of audits by aviation organizations.</p><p>Geoffrey Thomas, editor-in-chief of AirlineRatings.com, said all airlines have incidents of some type every day — and that it’s the way the flight crew handles these incidents that distinguishes a good airline from an unsafe one.</p><table><thead><tr><th>flight time</th><th><strong>airline</strong></th><th>speed up</th><th>as well as</th><th><strong>jets</strong></th></tr></thead><tbody><tr><td>飞行时间</td><td>航空公司</td><td>加速</td><td>以及</td><td>飞机</td></tr></tbody></table><table><thead><tr><th><strong>looking at</strong></th><th>crashes</th><th>luxurious</th><th>nanny</th><th>incident</th></tr></thead><tbody><tr><td>看着</td><td>崩溃</td><td>豪华</td><td>保姆</td><td>事件</td></tr></tbody></table><table><thead><tr><th>audit</th><th>distinguishes</th></tr></thead><tbody><tr><td>审计</td><td>区别</td></tr></tbody></table><h4 id="结合中文"><a href="#结合中文" class="headerlink" title="结合中文"></a>结合中文</h4><p>Qantas Named World’s Safest Airline for 2023<br>澳洲航空被评为 2023 年全球最安全的航空公司</p><ul><li><p>While things like price and flight time might be important when buying an airline ticket, there’s probably nothing more important than feeling safe when that plane starts to speed up on the runway before shooting up into the sky.<br>虽然在购买机票时，价格和飞行时间等因素可能很重要，但当飞机在冲上天空之前开始在跑道上加速时，可能没有什么比感到安全更重要的了。</p></li><li><p>If safety is the thing you’re most worried about, AirlineRatings.com may be able to help: the website has announced its top 20 safest airlines for 2023, chosen out of 385 airlines watched by the site.<br>如果安全是您最担心的事情，AirlineRatings.com 可能会有所帮助：该网站宣布了 2023 年最安全的 2023 家航空公司，这些航空公司是从该网站关注的 385 家航空公司中选出的。</p></li><li><p>According to the website, the safest airline for 2023 is the Australian airline Qantas.<br>根据该网站，2023 年最安全的航空公司是澳大利亚航空公司澳洲航空。</p><p>Started in 1920, it’s now the world’s second-oldest airline, as well as the largest in Australia.<br>它始于1920年，现在是世界上第二古老的航空公司，也是澳大利亚最大的航空公司。</p></li><li><p><strong>AirlineRatings.com notes that it’s known for its experience and its safety.</strong><br><strong>AirlineRatings.com 指出，它以其经验和安全性而闻名。</strong></p></li><li><p>Next is Air New Zealand. 接下来是新西兰航空公司。</p><p><strong>It’s not quite as old as Qantas — but that might be a good thing,</strong> since it also has younger aircraft, with most of its passenger jets less than 10 years old.<br><strong>它没有澳洲航空那么古老 - 但这可能是一件好事</strong>，因为它也有更年轻的飞机，大多数客机都不到10年。</p><p>It also runs one of the longest flights in the world: 17-and-a-half hours between New York and Auckland.<br>它还运行世界上最长的航班之一：纽约和奥克兰之间17个半小时。</p></li><li><p>Third is Etihad Airways, the national airline of the United Arab Emirates.<br>第三是阿联酋国家航空公司阿提哈德航空。</p><p>Just 20 years old, it’s known for its <strong>luxurious service</strong> — such as <strong>nannies</strong> for young children on long flights.<br>它只有20年的历史，以其豪华的服务而闻名 - 例如长途航班上的幼儿保姆。</p><p>And its planes are even younger than Air New Zealand’s.<br>它的飞机甚至比新西兰航空公司的还要年轻。</p></li><li><p>Fourth and fifth are Qatar Airways and Singapore Airlines.<br>第四和第五是卡塔尔航空公司和新加坡航空公司。</p><p>Singapore Airlines runs the world’s longest flight — 19 hours from New York to Singapore.<br>新加坡航空公司运营着世界上最长的航班 - 从纽约到新加坡的19小时。</p></li><li><p>AirlineRatings.com chose the safest airlines by <strong>looking at</strong> <strong>crashes</strong> over five years, serious incidents over two years, pilot training, the age of the airline’s planes, coronavirus rules, and the results of audits by aviation organizations.<br>AirlineRatings.com 通过查看五年内的坠机事故、两年内的严重事故、飞行员培训、航空公司飞机的年龄、冠状病毒规则以及航空组织的审计结果来选择最安全的航空公司。</p></li><li><p>Geoffrey Thomas, editor-in-chief of AirlineRatings.com, said all airlines have incidents of some type every day — and that it’s the way the flight crew handles these incidents that distinguishes a good airline from an unsafe one.<br>《AirlineRatings.com》杂志主编杰弗里·托马斯（Geoffrey Thomas）表示，所有航空公司每天都会发生某种类型的事故，而机组人员处理这些事件的方式将一家好的航空公司与不安全的航空公司区分开来。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot利用AOP实现记录操作日志</title>
      <link href="/2023/09/20/SpringBoot%E5%88%A9%E7%94%A8AOP%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BD%95%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%20-%20%E5%89%AF%E6%9C%AC/"/>
      <url>/2023/09/20/SpringBoot%E5%88%A9%E7%94%A8AOP%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BD%95%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%20-%20%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="利用AOP实现记录操作日志"><a href="#利用AOP实现记录操作日志" class="headerlink" title="利用AOP实现记录操作日志"></a>利用AOP实现记录操作日志</h2><h4 id="首先导入AOP依赖"><a href="#首先导入AOP依赖" class="headerlink" title="首先导入AOP依赖"></a>首先导入AOP依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--aop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建OperateLog实体类 （pojo包）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mpk.project.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperateLog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String ipAddress;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime operateTime;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> String methodParams;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> costTime;</span><br><span class="line">    <span class="keyword">private</span> String jsonString;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建aop-LogAop-（aop包）"><a href="#创建aop-LogAop-（aop包）" class="headerlink" title="创建aop.LogAop （aop包）"></a>创建aop.LogAop （aop包）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mpk.project.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.mpk.project.pojo.OperateLog;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mpk16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAop</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HttpServletRequest request;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(com.mpk.project.anno.Log)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">recordLog</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//操作人的IP</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ipAddress</span> <span class="operator">=</span> request.getRemoteAddr();</span><br><span class="line">        <span class="comment">//操作时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">operateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//操作类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//操作方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//操作方法参数</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodParams</span> <span class="operator">=</span> Arrays.toString(args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用原始目标方法运行</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//操作耗时</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> end - begin;</span><br><span class="line">        <span class="comment">//方法返回值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">returnValue</span> <span class="operator">=</span> JSONObject.toJSONString(result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">OperateLog</span> <span class="variable">operateLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OperateLog</span>(ipAddress, operateTime, className, methodName, </span><br><span class="line">                methodParams,costTime, returnValue);</span><br><span class="line">        <span class="comment">//只是打印了一下未写入数据库中</span></span><br><span class="line">        System.out.println(operateLog);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用JSONObject需添加依赖"><a href="#使用JSONObject需添加依赖" class="headerlink" title="使用JSONObject需添加依赖"></a>使用JSONObject需添加依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义注解anno-Log-（anno包下）"><a href="#自定义注解anno-Log-（anno包下）" class="headerlink" title="自定义注解anno.Log （anno包下）"></a>自定义注解anno.Log （anno包下）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mpk.project.anno;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并标注在需要记录日志的方法上-（Controller层）"><a href="#并标注在需要记录日志的方法上-（Controller层）" class="headerlink" title="并标注在需要记录日志的方法上 （Controller层）"></a>并标注在需要记录日志的方法上 （Controller层）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span> <span class="comment">//跨域</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span>  UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Log</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    Result <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestBody</span> User user1)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getUser(user1);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            HashMap&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            claims.put(<span class="string">&quot;name&quot;</span>, user.getName());</span><br><span class="line">            claims.put(<span class="string">&quot;gender&quot;</span>, user.getGender());</span><br><span class="line">            claims.put(<span class="string">&quot;area&quot;</span>, user.getArea());</span><br><span class="line">            <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> JwtUtils.generateJwt(claims);</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims1</span> <span class="operator">=</span> JwtUtils.parseJWT(jwt);</span><br><span class="line">            System.out.println(claims1);</span><br><span class="line">            <span class="keyword">return</span> Result.success(jwt);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="service层-mapper层用mybatis-plus实现-（省略）"><a href="#service层-mapper层用mybatis-plus实现-（省略）" class="headerlink" title="service层 ,mapper层用mybatis-plus实现 （省略）"></a>service层 ,mapper层用mybatis-plus实现 （省略）</h4>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> study </tag>
            
            <tag> AOP </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日英语09-19</title>
      <link href="/2023/09/19/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD09-19/"/>
      <url>/2023/09/19/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD09-19/</url>
      
        <content type="html"><![CDATA[<h2 id="每日英语"><a href="#每日英语" class="headerlink" title="每日英语"></a>每日英语</h2><h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><p>Language Experts Fail to <strong>Identify</strong> AI-Written Texts</p><p>Even experts in <strong>linguistics</strong> are unable to tell if research <strong>summaries</strong> are written by artificial intelligence (AI) or humans, a study found.</p><p>Two US researchers asked 72 <strong>linguists</strong> and journal editors to look at short summaries of research, and identify which ones were written by the ChatGPT chatbot.</p><p>The experts were only able to correctly identify articles written by ChatGPT 39% of the time, said researchers Matt Kessler of the University of South Florida and J. Elliott Casal of the University of Memphis.</p><p>The experts used various ways to study the texts, but they were “largely unsuccessful” in identifying AI writing as being different from human writing, Kessler and Casal wrote in <em>Research Methods in Applied Linguistics</em>.</p><p>When they were asked how they decided which texts were written by AI, the experts gave “very logical reasons,” but were not <strong>accurate</strong> or <strong>consistent</strong>, Kessler said.</p><p>The researchers said the study showed that ChatGPT can write short texts “just as well as most humans, if not better in some cases.”</p><p>But they said research summaries are short and simple pieces of writing.</p><p>For a longer piece of writing, AI will sometimes “make up content, making it easier to identify” that AI created it, Kessler said.</p><p>Kessler has used the research to change how he gives work to his linguistics students.</p><p>He doesn’t want them to write short summaries, which “ChatGPT can do quite easily,” he says.</p><p>Instead, Kessler wants his students to write more about their own experiences, such as how they use an app to learn a foreign language.</p><p>An earlier survey of 1,900 Americans by Tooltester found that up to 64% of people could not identify text written by AI.</p><h3 id="来点翻译"><a href="#来点翻译" class="headerlink" title="来点翻译"></a>来点翻译</h3><p>Language Experts Fail to Identify AI-Written Texts<br>语言专家无法识别人工智能书面文本</p><p>Even experts in linguistics are unable to tell if research summaries are written by artificial intelligence (AI) or humans, a study found.<br>一项研究发现，即使是语言学专家也无法判断研究摘要是由人工智能（AI）还是人类撰写的。</p><p>Two US researchers asked 72 linguists and <strong>journal editors</strong> to look at short summaries of research, and identify which ones were written by the ChatGPT chatbot.<br>两名美国研究人员要求72名语言学家和期刊编辑查看研究的简短摘要，并确定哪些是由ChatGPT聊天机器人撰写的。</p><p>The experts were only able to correctly identify articles written by ChatGPT 39% of the time, said researchers Matt Kessler of the University of South Florida and J. Elliott Casal of the University of Memphis.<br>专家们只能在39%的时间内正确识别ChatGPT撰写的文章，南佛罗里达大学的研究人员Matt Kessler和孟菲斯大学的J. Elliott Casal说。</p><p>The experts used various ways to study the texts, but they were “largely unsuccessful” in identifying AI writing as being different from human writing, Kessler and Casal wrote in <em>Research Methods in Applied Linguistics</em>.<br>专家们使用了各种方法来研究文本，但他们在识别人工智能写作与人类写作不同方面“基本上没有成功”，凯斯勒和卡萨尔在应用语言学研究方法中写道。</p><p>When they were asked how they decided which texts were written by AI, the experts gave “very logical reasons,” but were not accurate or consistent, Kessler said.<br>凯斯勒说，当他们被问及如何决定哪些文本是由人工智能编写时，专家们给出了“非常合乎逻辑的理由”，但并不准确或一致。</p><p>The researchers said the study showed that ChatGPT can write short texts “just as well as most humans, if not better in some cases.”<br>研究人员表示，研究表明，ChatGPT可以写出“和大多数人一样好的短文本，如果在某些情况下不是更好的话”。</p><p>But they said research summaries are short and simple pieces of writing.<br>但他们表示，研究摘要是简短而简单的写作。</p><p>For a longer piece of writing, AI will sometimes “<strong>make up content</strong>, making it easier to identify” that AI created it, Kessler said.<br>凯斯勒说，对于更长的文章，人工智能有时会“编造内容，更容易识别”人工智能创造了它。</p><p>Kessler has used the research to change how he gives work to his linguistics students.<br>凯斯勒利用这项研究改变了他给语言学学生工作的方式。</p><p>He doesn’t want them to write short summaries, which “ChatGPT can do quite easily,” he says.<br>他不希望他们写简短的摘要，“ChatGPT可以很容易地做到这一点，”他说。</p><p>Instead, Kessler wants his students to write more about their own experiences, such as how they use an app to learn a foreign language.<br>相反，凯斯勒希望他的学生写更多关于他们自己的经历，比如他们如何使用应用程序学习外语。</p><p>An earlier survey of 1,900 Americans by Tooltester found that up to 64% of people could not identify text written by AI.</p><p>早些时候对1,900名美国人进行的一项调查发现，高达64%的人无法识别AI编写的文本。</p><table><thead><tr><th align="center">Identify</th><th align="center">linguistics</th><th align="center">summaries</th><th align="center">accurate</th><th align="center">consistent</th></tr></thead><tbody><tr><td align="center">识别</td><td align="center">语言学</td><td align="center">摘要</td><td align="center">准确</td><td align="center">一致</td></tr></tbody></table><table><thead><tr><th align="center">journal editors</th><th>various ways</th><th align="center">make up content</th><th></th><th></th></tr></thead><tbody><tr><td align="center">期刊编辑</td><td>各种方式</td><td align="center">编造内容</td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2023/09/19/Spring/"/>
      <url>/2023/09/19/Spring/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><p>事务是一组操作的集合，他是一个不可分割的工作单位，这些操作 要么同事成功，要么同事失败。</p><h3 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h3><ul><li><p>注解：@Transactional</p></li><li><p>位置：业务（service）层的方法上、类上、接口上</p></li><li><p>作用：将当前方法交给spring进行事务管理，方法执行前，开启事务;成功执行完毕，提交事务;出现异常，回滚事务</p></li></ul><p>​            一般增加在业务的增删改上，而且是多次数据访问</p><h4 id="事务进阶"><a href="#事务进阶" class="headerlink" title="事务进阶"></a>事务进阶</h4><h5 id="rollbackFor"><a href="#rollbackFor" class="headerlink" title="rollbackFor"></a>rollbackFor</h5><p>默认情况下，只有出现RuntimeException 才回滚异常。rollbackFor属性用于控制出现何种异常类型，回滚事务。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span> (rollbackFor= Exception.class)</span><br></pre></td></tr></table></figure><h5 id="propagation"><a href="#propagation" class="headerlink" title="propagation"></a>propagation</h5><p>事务传播行为:指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation= Propagation.REQUIRED)</span></span><br><span class="line"><span class="comment">//【默认值】需要事务，有则加入，无则创建新事务</span></span><br><span class="line"><span class="meta">@Transactional(propagation= Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="comment">//需要新事务，无论有无,总是创建新事务</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment">#开启事务管理日志</span></span><br><span class="line">    <span class="attr">org.springframework.jdbc.support.JdbcTransactionManager:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><h4 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h4><p>概念:AOP(Aspect Oriented Programming)面向切面编程，一种编程范式作用︰在不惊动原始设计的基础上为方法进行功能增强</p><h5 id="AOP的应用场景"><a href="#AOP的应用场景" class="headerlink" title="AOP的应用场景"></a>AOP的应用场景</h5><ul><li>日志记录</li><li>事务管理</li><li>权限验证</li><li>性能监测</li></ul><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AOP依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mpk.project.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mpk</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span>  <span class="comment">//声明当前类为Aspect切面，并交给Spring容器管理</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.mpk.project.service.impl.StudentServiceImpl.* (..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//前置通知   </span></span><br><span class="line">        <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeAdvice</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">           log.info( <span class="string">&quot;========== 【Aspectj前置通知 Before】 ==========&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//后置通知：方法正常执行后，有返回值，执行该后置通知：如果该方法执行出现异常，则不执行该后置通知</span></span><br><span class="line">        <span class="meta">@AfterReturning(value = &quot;pt()&quot;,returning = &quot;returnVal&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturningAdvice</span><span class="params">(JoinPoint joinPoint,Object returnVal)</span>&#123;</span><br><span class="line">           log.info(<span class="string">&quot;========== 【Aspectj后置通知 AfterReturning】 ==========&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后置通知</span></span><br><span class="line">        <span class="meta">@After(&quot;pt()&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterAdvice</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">           log.info(<span class="string">&quot;========== 【Aspectj后置通知 After】 ==========&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//环绕通知</span></span><br><span class="line">        <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">           log.info(<span class="string">&quot;##########【环绕通知中的前置通知 Around】##########&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">returnVale</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">           log.info(<span class="string">&quot;##########【环绕通知中的后置通知 Around】##########&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> returnVale;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异常通知：方法出现异常时，执行该通知</span></span><br><span class="line">        <span class="meta">@AfterThrowing(value = &quot;pt()&quot;,throwing = &quot;ex&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">throwAdvice</span><span class="params">(JoinPoint joinPoint, Exception ex)</span>&#123;</span><br><span class="line">           log.info(<span class="string">&quot;********** 【Aspectj异常通知 AfterThrowing】执行开始 **********&quot;</span>);</span><br><span class="line">           log.info(<span class="string">&quot;出现异常：&quot;</span> + ex.getMessage());</span><br><span class="line">           log.info(<span class="string">&quot;********** 【Aspectj异常通知 AfterThrowing】执行结束 **********&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ol><li>连接点(joinPoint)</li></ol><p>​    2. 切入点(<a href="https://so.csdn.net/so/search?q=Pointcut&spm=1001.2101.3001.7020">Pointcut</a>)</p><p>​    3. 通知(Advice)</p><p>​    4. 通知类</p><p>​     5.切面(Aspect)</p><h4 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h4><h5 id="Spring中AOP的通知类型"><a href="#Spring中AOP的通知类型" class="headerlink" title="Spring中AOP的通知类型"></a>Spring中AOP的通知类型</h5><ul><li><p>@Around：环绕通知，此注解标注的通知方法在目标方法前、后都被执行</p></li><li><p>@Before：前置通知，此注解标注的通知方法在目标方法前被执行</p></li><li><p>@After ：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行</p></li><li><p>@AfterReturning ： 返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行</p></li><li><p>@AfterThrowing ： 异常后通知，此注解标注的通知方法发生异常后执行</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">- 程序没有发生异常的情况下:</span><br><span class="line"></span><br><span class="line">@AfterThrowing标识的通知方法不会执行。</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">- 程序发生异常的情况下：</span><br><span class="line"></span><br><span class="line">@AfterThrowing标识的通知方法执行了，@AfterReturning标识的通知方法不会执行</span><br><span class="line">@Around环绕通知中原始方法调用时有异常，通知中的环绕后的代码逻辑也不会在执行了 （因为原始方法调用已经出异常了）</span><br></pre></td></tr></table></figure></li></ul><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>@Around环绕通知需要自己调用 ProceedingJoinPoint.proceed() 来让原始方法执行，其他通知不需要考虑目标方法执行<br>@Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值，否则原始方法执行完毕，是获取不到返回值的。</p><h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><h5 id="2-1-语法格式"><a href="#2-1-语法格式" class="headerlink" title="2.1 语法格式"></a>2.1 语法格式</h5><p>切入点表达式标准式：动作关键字(访问修饰符 返回值 包名.类&#x2F;接口名.方法名(参数) 异常名)</p><p>对于这个格式，我们不需要硬记，通过一个例子，理解它:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution(public User com.itheima.service.UserService.findById(java.lang.Intager))</span><br></pre></td></tr></table></figure><ul><li>execution：动作关键字，描述切入点的行为动作，例如execution表示执行到指定切入点</li><li>public: 访问修饰符,还可以是public，private等，可以省略</li><li>User：返回值，写返回值类型</li><li>com.itheima.service：包名，多级包使用点连接</li><li>UserService:类&#x2F;接口名称</li><li>findById：方法名</li><li>int:参数，直接写参数的类型，多个类型用逗号隔开</li><li>异常名：方法定义中抛出指定异常，可以省略</li></ul><h5 id="2-2通配符"><a href="#2-2通配符" class="headerlink" title="2.2通配符"></a>2.2通配符</h5><p>*****：单个独立的任意符号。可以独立出现，也可以作为前缀或者后缀的匹配符出现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution（public * com.itheima.*.UserService.find*(*))</span><br></pre></td></tr></table></figure><p>匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法</p><p>**..**：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execution（public User com..UserService.findById(..))</span><br></pre></td></tr></table></figure><p>匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法。参数任意，可以带，可以不带，可以带多个。</p><h4 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a>连接点</h4><p>连接点是可以被AOP控制的方法。</p><ul><li>对于@Around通知，获取连接点信息只能使用ProceedingJoinPoint类型</li><li>对于其他四种通知，获取连接点信息只能使用JoinPoint，它是ProceedingJoinPoint的父类型</li></ul><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
            <tag> spring </tag>
            
            <tag> 事务管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mrakdown语法</title>
      <link href="/2023/09/18/Mrakdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/09/18/Mrakdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Markdown-文档用法"><a href="#Markdown-文档用法" class="headerlink" title="Markdown 文档用法"></a>Markdown 文档用法</h2><h4 id="标题、目录、页眉"><a href="#标题、目录、页眉" class="headerlink" title="标题、目录、页眉"></a>标题、目录、页眉</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">页眉</span><br><span class="line">--- 在第一行是页眉， 在别的地方是分割线</span><br><span class="line">目录</span><br><span class="line">[toc] 回车</span><br><span class="line">标题</span><br><span class="line">文字前面加　<span class="params">#</span>　回车，总共是ｈ１－ｈ６文字前面加一到六个＃，分别对应一级标题到六级标题</span><br></pre></td></tr></table></figure><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span> 无序列表 可以在文字前面加 * 、+、-号 然后空格，这三种符号任意一种</span><br><span class="line"> <span class="params">######</span> A</span><br><span class="line">  * a</span><br><span class="line">  * b</span><br><span class="line">  * c</span><br><span class="line">  + d</span><br><span class="line">  + e</span><br><span class="line">  + f</span><br><span class="line">  - g</span><br><span class="line">  - h</span><br><span class="line">  - i</span><br><span class="line"></span><br><span class="line"><span class="params">#</span>　有序列表　就更简单了，数字后面加英文的点　然后空格就可以了</span><br><span class="line"> <span class="params">######</span> B</span><br><span class="line"> 1. j</span><br><span class="line"> 2. k</span><br><span class="line"> 3. l</span><br></pre></td></tr></table></figure><h5 id="A"><a href="#A" class="headerlink" title="A"></a>A</h5><ul><li>a</li><li>b</li><li>c</li></ul><ul><li>d</li><li>e</li><li>f</li></ul><ul><li>g</li><li>h</li><li>i</li></ul><h5 id="B"><a href="#B" class="headerlink" title="B"></a>B</h5><pre><code>1.  j2.  k3.  l</code></pre><h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">*字体倾斜*</span><br><span class="line"><span class="built_in">_</span>字体倾斜<span class="built_in">_</span></span><br><span class="line">**字体加粗**</span><br><span class="line"><span class="built_in">_</span><span class="built_in">_</span>字体加粗<span class="built_in">_</span><span class="built_in">_</span></span><br></pre></td></tr></table></figure><p><em>字体倾斜</em><br><em>字体倾斜</em><br><strong>字体加粗</strong><br><strong>字体加粗</strong></p><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">* <span class="keyword">\\</span></span><br><span class="line">* <span class="keyword">\`</span></span><br><span class="line">* <span class="keyword">\~</span></span><br><span class="line">* <span class="keyword">\*</span></span><br><span class="line">* <span class="keyword">\_</span></span><br><span class="line">* <span class="keyword">\-</span></span><br><span class="line">* <span class="keyword">\+</span></span><br><span class="line">* <span class="keyword">\.</span></span><br><span class="line">* <span class="keyword">\!</span></span><br></pre></td></tr></table></figure><ul><li>\</li><li>`</li><li>~</li><li>*</li><li>_</li><li>-</li><li>+</li><li>.</li><li>!</li></ul><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p><del>删除线</del></p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[百度1](www.baidu.com)</span><br></pre></td></tr></table></figure><p><a href="www.baidu.com">百度1</a></p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">![图片](https://note.youdao.com/favicon.ico)</span><br><span class="line">&lt;img src=&quot;https://note.youdao.com/favicon.ico&quot;/&gt;</span><br></pre></td></tr></table></figure><p> <img src="https://note.youdao.com/favicon.ico" alt="图片"></p><img src="https://note.youdao.com/favicon.ico"/><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- - -</span><br><span class="line">-------</span><br><span class="line">*****</span><br><span class="line">* * *</span><br><span class="line"><span class="built_in">_</span><span class="built_in">_</span><span class="built_in">_</span><span class="built_in">_</span></span><br></pre></td></tr></table></figure><hr><hr><hr><hr><hr><hr><h4 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">- [ ] 复选框</span><br><span class="line">- [x] 选中状态</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> 复选框</li><li><input checked="" disabled="" type="checkbox"> 选中状态</li></ul><p>&#96;</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心灵鸡汤</title>
      <link href="/2023/09/18/%E5%BF%83%E7%81%B5%E9%B8%A1%E6%B1%A4/"/>
      <url>/2023/09/18/%E5%BF%83%E7%81%B5%E9%B8%A1%E6%B1%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="心灵鸡汤"><a href="#心灵鸡汤" class="headerlink" title="心灵鸡汤"></a>心灵鸡汤</h2><h3 id="希望"><a href="#希望" class="headerlink" title="希望"></a>希望</h3><ul><li><p>希望是一束明亮的光芒，照亮前行的道路，激发我们不断努力的动力。在生活中，希望是我们前进的动力，是战胜逆境的力量，是追求梦想的源泉。</p></li><li><p>有时候，生活可能会让我们感到迷茫，困难和挫折似乎无处不在。但正是在这些时刻，希望才显得尤为重要。它是我们坚持不懈的原因，是我们振作精神的力量。</p></li><li><p>无论遇到多大的困难，无论前路多么坎坷，我们都要相信，希望永远存在。它是那道不灭的火焰，即使在最黑暗的夜晚也能照亮我们的前程。</p></li><li><p>希望让我们勇往直前，不怕失败，不怕困难。它让我们敢于追求自己的梦想，去探索未知的世界，去创造美好的未来。</p></li><li><p>因此，无论您现在身处何地，无论遇到什么困境，都请记住：希望是您最强大的朋友，它永远在那里，为您点亮前行的路。愿您永远怀着希望，坚定不移地追逐自己的梦想，因为希望永远存在，只要您坚信不疑。</p></li></ul><h3 id="学点英语吧"><a href="#学点英语吧" class="headerlink" title="学点英语吧"></a>学点英语吧</h3><p>“Hope is like a shining star in the darkest of nights, guiding us towards a brighter tomorrow. It’s the strength that fuels our determination when life’s challenges seem insurmountable. Even in the face of adversity, hope remains our unwavering companion, lighting the way forward.</p><p>No matter how tough the journey may be, always remember that hope is a powerful ally that never deserts us. It’s the eternal flame that can illuminate even the darkest of paths.</p><p>So, wherever you are right now and whatever challenges you may be facing, keep in mind: hope is your greatest ally. It’s always there, ready to light your path. May you always hold onto hope, relentlessly pursuing your dreams, for hope never fades as long as you believe.”</p><h3 id="to-do-better"><a href="#to-do-better" class="headerlink" title="to do better"></a>to do better</h3><p>Striving to do better is a commendable and essential aspect of personal growth and development. Here are some thoughts on this topic:</p><ol><li><strong>Continuous Improvement</strong>: The desire to do better often stems from a commitment to continuous improvement. It’s the acknowledgment that there is always room for growth and learning. Embrace this mindset, and you’ll find yourself on a journey of self-improvement that knows no bounds.</li><li><strong>Setting Goals</strong>: To do better, it helps to set clear and achievable goals. These goals act as a roadmap, guiding your efforts and providing a sense of direction. Whether they’re related to your career, personal life, or skills, having goals can motivate you to strive for excellence.</li><li><strong>Learning and Adapting</strong>: One of the most effective ways to do better is through learning. Be open to new experiences, seek out knowledge, and be willing to adapt. Remember that mistakes and failures are valuable opportunities for growth. They provide valuable lessons that can help you improve.</li><li><strong>Consistency and Discipline</strong>: Doing better often requires consistency and discipline. It’s not just about occasional bursts of effort; it’s about committing to continuous, steady progress. Establishing good habits and routines can be instrumental in achieving this.</li><li><strong>Self-Reflection</strong>: Take time to reflect on your actions, decisions, and outcomes. Self-reflection allows you to assess what’s working and what needs improvement. It’s a vital tool for personal development.</li><li><strong>Seeking Feedback</strong>: Don’t hesitate to seek feedback from others, whether it’s from mentors, peers, or loved ones. Constructive feedback can offer valuable insights and perspectives you might not have considered on your own.</li><li><strong>Balance and Self-Care</strong>: While the pursuit of improvement is important, it’s equally crucial to strike a balance. Overworking or pushing too hard can lead to burnout. Make sure to incorporate self-care into your journey of doing better to ensure your physical and mental well-being.</li><li><strong>Celebrate Achievements</strong>: Acknowledge and celebrate your successes along the way, no matter how small they may seem. Celebrating achievements can boost your motivation and remind you of the progress you’ve made.</li><li><strong>Inspiration and Role Models</strong>: Look up to inspirational figures or role models who have achieved what you aspire to do. Their stories can serve as a source of motivation and guidance.</li><li><strong>Gratitude</strong>: Cultivate a sense of gratitude for the opportunities and resources that enable you to strive for improvement. Gratitude can keep you grounded and appreciative of your journey.</li></ol><p>Remember that doing better is a personal journey, and everyone’s path is unique. It’s about becoming the best version of yourself, both for your own fulfillment and for the positive impact you can have on others and the world around you.</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日英语</title>
      <link href="/2023/09/18/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD09-18/"/>
      <url>/2023/09/18/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD09-18/</url>
      
        <content type="html"><![CDATA[<h2 id="Bear-Cam-Saves-Lost-Hiker’s-Life"><a href="#Bear-Cam-Saves-Lost-Hiker’s-Life" class="headerlink" title="Bear Cam Saves Lost Hiker’s Life"></a>Bear Cam Saves Lost Hiker’s Life</h2><p>熊凸轮拯救了迷路的徒步旅行者的生命</p><p>Wildlife fans watching live video from an Alaskan national park have helped save a man’s life.<br>野生动物迷观看阿拉斯加国家公园的现场视频帮助挽救了一名男子的生命。</p><p>Viewers watching live video from Dumpling Mountain in Katmai National Park on September 5 were probably hoping to see <strong>bears</strong>.<br>9月5日在卡特迈国家公园观看饺子山直播视频的观众可能希望看到熊。Instead, around 3:15 p.m. they saw a man, who looked cold and wet, walk up to the camera and <strong>give the thumbs down signal.</strong><br>相反，在下午3点15分左右，他们看到一名看起来又冷又湿的男子走到镜头前，发出了竖起大拇指的信号。</p><p>A few minutes later the man returned, and spoke to the camera.<br>几分钟后，这名男子回来了，对着镜头说话。Because it was windy, the sound was not clear, but the man seemed to be saying the words “lost” and “help me.”<br>因为刮风，声音不清晰，但那人似乎在说“迷路”和“救救我”这两个字。</p><p>The area has no cellphone signal, and the weather was bad that day, with wind, rain and <strong>fog</strong>.<br>该地区没有手机信号，当天天气恶劣，有风雨和雾。</p><p>People watching the video on Explore.org <strong>posted</strong> <strong>comments</strong> saying the man <strong>was in trouble</strong>, and <strong>staff at the website</strong> then <strong>contacted</strong> the National Park Service.<br>在 Explore.org 上观看视频的人发表评论说这名男子遇到了麻烦，该网站的工作人员随后联系了国家公园管理局。</p><p>The park sent a team to <strong>look for</strong> the <strong>hiker</strong>, and by 6:48 p.m. they found him — still near the camera — and they were able to take him safely off the mountain.<br>公园派出了一个团队寻找徒步旅行者，到下午6点48分，他们找到了他 - 仍然在相机附近 - 他们能够将他安全带下山。</p><p>Katmai National Park has seven cameras, which are used to show <strong>live video</strong> of the park’s scenery and wildlife.<br>卡特迈国家公园有七个摄像头，用于显示公园风景和野生动物的实时视频。People often watch the videos to see the park’s bears, with over 2,000 of the animals believed to live in the park.<br>人们经常观看视频，看看公园里的熊，据信有超过2000只动物生活在公园里。</p><p>The park is <strong>also well-known for</strong> its Fat Bear Week, an online competition held every October, in which people vote for the fattest bear of the year.<br>该公园还以其肥熊周而闻名，这是每年十月举行的在线比赛，人们投票选出年度最胖的熊。Bears need to get fat before winter, and at this time of year people enjoy watching live video of the bears catching salmon to eat.<br>熊需要在冬天之前变胖，每年的这个时候，人们都喜欢观看熊捕捉鲑鱼吃的直播视频。</p><p>However, on the day the <strong>hiker</strong> <strong>got lost</strong> in early September, he was very lucky, because only a few people were watching when he spoke to the camera.<br>然而，在9月初徒步旅行者迷路的那天，他非常幸运，因为当他对着镜头说话时，只有少数人在看。</p><h3 id="生词"><a href="#生词" class="headerlink" title="生词"></a>生词</h3><table><thead><tr><th>live video</th><th>bears</th><th>thumbs</th><th>fog</th><th>staff</th></tr></thead><tbody><tr><td>直播</td><td>熊</td><td>拇指</td><td>雾</td><td>工作人员</td></tr></tbody></table><table><thead><tr><th>hiker</th><th>Viewers</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>徒步旅行者</td><td>观众</td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My New Post</title>
      <link href="/2023/09/17/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD09-17/"/>
      <url>/2023/09/17/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD09-17/</url>
      
        <content type="html"><![CDATA[<h1 id="English-Book"><a href="#English-Book" class="headerlink" title="English Book"></a>English Book</h1><hr><p>I think this role perfectly matches my professional goals and ambitions.<br><br>我认为这个角色完全符合我的职业目标和抱负。</p><hr><p> perfectly matches  完全匹配</p><hr><p>Japan Least Nervous About AI in International Survey<br>国际调查中日本对人工智能最不紧张</p><table><thead><tr><th>matches</th><th>drawback</th><th align="left">Greeting</th><th align="left">well-being score</th><th>fence</th></tr></thead><tbody><tr><td>匹配</td><td>缺点</td><td align="left">问候，打招呼</td><td align="left">幸福感</td><td>栅栏</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
