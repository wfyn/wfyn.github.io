---
title: Comparable与Compartor
date: 2024-5-24 11:02:27
tags: 
	- javase
	- Comparable
	- Comparator
categories: java
top_img: /images/bg2.jpg
---



总有些惊奇的际遇，

#### 1.自然排序 （Comparable）

- 当一个类实现了`java.lang.Comparable`接口时，它就可以进行自然排序。`Comparable`接口中有一个方法`compareTo(T o)`，用于定义对象之间的比较规则。实现了该接口的类可以直接使用Java提供的排序方法（如`Collections.sort()`或`Arrays.sort()`）进行排序。

#### 2.定制排序（Comparator）

- 定制排序通常用于对那些没有实现`Comparable`接口的类进行排序，或者当需要按照不同的规则进行排序时。
- 在这种情况下，可以使用`java.util.Comparator`接口。`Comparator`接口有一个`compare(T o1, T o2)`方法，用于定义对象之间的比较规则。可以创建一个新的比较器类实现`Comparator`接口，或者使用匿名类或Lambda表达式创建一个临时的比较器。

例如：

```java
package com.igeek.javase.ch06.work.test4;

import java.time.LocalDate;
/**
 * @author mpk16
 * 6.新闻类：标题，内容，时间   三个属性。 有10条新闻，按照时间的降序排列。
 *
 * 如果希望当前类的对象 具备 比较性：需要实现接口Comparable<T> 泛型T： 需要比较的对象的类型
 * 接口中 只有一个抽象方法：int compareTo(T o)
 * x.compareTo(y)
 * 返回值： 0      表示 x和y是相同的
 * 返回值： 大于0   表示 x>y
 * 返回值： 小于0   表示 x<y
 */
public class News implements Comparable<News>{
    private String title;//标题
    private String content;//内容
    private LocalDate date;//时间


    public News() {
    }

    public News(String title, String content, LocalDate date) {
        this.title = title;
        this.content = content;
        this.date = date;
    }
    @Override
    public int compareTo(News o) {
        //根据News的date属性来进行比较  如果 返回值>0表示 this对象的时间大于o对象的时间
        //LocalDate 间接实现了Comparable接口，通过compareTo方法可以直接比较两个date对象的大小

        //return this.date.compareTo(o.date); //实现升序的排序规则
        return o.date.compareTo(this.date); //实现降序的排序规则
    }


    public String toString() {
        return "News{title = " + title + ", content = " + content + ", date = " + date + "}";
    }
}

```

```java
package com.igeek.javase.ch06.work.test4;

import java.time.LocalDate;
import java.util.Arrays;
import java.util.Comparator;

/**
 * @Author fengqq
 * @Description TODO
 * @Date 2024/5/24  10:04
 *
 * 数组的排序
 * Arrays.sort(T[]);                    默认使用Comparable接口的compareTo方法来实现比较规则
 * Arrays.sort(T[],Comparator comp);    不使用默认的Comparable接口，指定使用Comparator接口的compare方法来实现比较规则
 *
 * 升序：this前一个元素 o后一个元素
 * 升序：o1前一个元素 o2后一个元素
 * int compareTo(T o)  this>o
 * int compare(T o1，T o2)  o1>o2
 *
 * 降序:
 * int compareTo(T o)  o>this
 * int compare(T o1，T o2)  o2>o1
 */
public class NewsTest {
    public static void main(String[] args) {
        //1.将News对象存储到数组中
        News[] news = new News[10];
        for (int i = 0; i < news.length; i++) {
            news[i] = new News("爆炸性新闻"+i,"天王级别"+i, LocalDate.of(2024,05,10+i));
        }
        System.out.println("Arrays.toString(news) = " + Arrays.toString(news));

        //2.1 将数组中元素进行降序排序 冒泡排序 从大到小
       /* for (int i = 0; i < news.length-1; i++) {// 轮数
            for (int j = 0; j < news.length-1-i; j++) { // j表示的是当前比较的位置
                //j 和 j+1 位置的元素进行比较 一旦前者比后者小，则交互位置
                if(news[j].getDate().compareTo(news[j+1].getDate())<0 ){ //if(news[j].compareTo(news[j+1])<0){
                    News temp = null;
                    temp = news[j+1];
                    news[j+1] = news[j];
                    news[j] = temp;
                }
            }
        }
        System.out.println("-----------------方式一：按照时间排序后的结果--------------------");
        System.out.println("Arrays.toString(news) = " + Arrays.toString(news));*/

        //2.2 使用Arrays.sort方法来直接实现排序  根据compareTo方法的返回值来排序 要求 if(compareTo方法的比较结果>0){x和y交互位置}
        //如果实现升序 则 x.compareTo(y)>0   x>y  前者大于后者 时交互元素位置
        //如果实现降序 则 y.compareTo(x)>0   y>x  前者小于后者 时交互元素位置
        //总结：如果直接使用Arrays.sort(T[] arr);要求数组中元素类型T 必须实现Comparable接口重写compareTo方法 否则会产生 ClassCastException
      /*  Arrays.sort(news);
        System.out.println("-----------------方式二：按照时间排序后的结果--------------------");
        System.out.println("Arrays.toString(news) = " + Arrays.toString(news));*/

        //2.3 使用Arrays.sort(T[] arr,Comparator comp)根据Comparator接口的compare方法来进行排序  适用于进行临时比较
        Arrays.sort(news, new Comparator<News>() {
            @Override
            public int compare(News o1, News o2) {//o1代表是前者对象  o2代表的是后者对象
                return o2.getDate().compareTo(o1.getDate());
            }
        });

        
        System.out.println("-----------------方式三：按照时间排序后的结果--------------------");
        System.out.println("Arrays.toString(news) = " + Arrays.toString(news));


    }
}

```



